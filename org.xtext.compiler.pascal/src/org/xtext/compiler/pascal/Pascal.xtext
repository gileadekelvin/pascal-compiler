grammar org.xtext.compiler.pascal.Pascal with org.eclipse.xtext.common.Terminals

generate pascal "http://www.xtext.org/compiler/pascal/Pascal"

pascal:
	program += program
; 

program:
	heading=program_heading_block block=block "." 
;

program_heading_block:
	"program" name=ID ( "(" identifiers=identifier_list ")" ) ? ";"	
;

identifier_list:
	names+=ID ( "," names+=ID ) *	
;

block:
	(constantpart+=constant_definition_part | 
	 variablepart+=variable_declaration_part | 
	 procedure_function_part+=procedure_and_function_declaration_part
	)* statement=compound_statement
;

constant_definition_part: 
	'const' (constants+=constant_definition ';') +
;

constant_definition: 
	name=ID EQUAL constant
;

constant: 
	 unsigned_number
   | sign unsigned_number
   | names+=ID
   | sign names+=ID
   | string+=STRING
   | constant_chr
   | booltype+=bool
;

variable_declaration_part
   : "var" variable+=variable_declaration (";" variable+=variable_declaration)* ";"
;

variable_declaration
   : identifier_list ":" types+=type
;

compound_statement:
	"begin" sequence=statements "end"	
;

statements:
	statements+=statement ( ";" statements+=statement ) *
;

statement:  
	label=label ":" statement+=unlabelled_statement | {statement} (statement+=unlabelled_statement) ? 
;

unlabelled_statement:
	simple=simple_statement | structured=structured_statement
;

label:
	number=unsigned_integer
;

simple_statement:
	assignment=assignment_statement | procedure=procedure_statement
;

assignment_statement: 
	variable=variable ASSIGN expression=expression	
;

variable
   : ('@' names+=ID | names+=ID) ('[' expression+=expression ("," expression+=expression)* ']' | "(." expression+=expression ("," expression+=expression)* ".)" | "." names+=ID | "^")*
;

expression:
	expressions+=simple_expression (operators+=relational_operator expressions+=expression)?
;

simple_expression:
	terms+=term (operators+=additive_operator expression+=simple_expression)?
;

term: 
	factors+=signed_factor (operators+=multiplicative_operator terms+=term)?
;

signed_factor: 
	(operators+=PLUS | operators+=MINUS)? factors+=factor
;

factor: 
	 variable=variable
   | "(" expression=expression ")"
   | function_designator
   | constant=unsigned_constant
   | set=set
   | NOT factor=factor
   | boolean+=bool
;

set: 
	 "[" elements+=elementList "]"
   | "(." elements+=elementList ".)"
;

elementList: 
	elements+=element ("," elements+=element)*   
;

element: 
	expressions+=expression (dotdot+=DOTDOT expressions+=expression)?
;

type: 
	  type+=simple_type
   	| type+=structured_type
;

simple_type:
 	 types+=scalar_type
   | types+=subrange_type
   | types+=type_identifier
   | types+=string_type
;

scalar_type
   : "(" identifier_list ")"
;

subrange_type: 
	constants+=constant DOTDOT constants+=constant
;

structured_type:
	"PACKED" unpacked_structured_type
   | unpacked_structured_type
;

unpacked_structured_type:
   array_type | dynamic=dynamic_array_type
;

array_type:
	"array" "[" type_list "]" "of" component+=component_type
   | "array" "(" type_list ")" "of" component+=component_type
;

dynamic_array_type:
	"array" "of" type=type	
;

type_list:
   indexes+=index_type ("," indexes+=index_type)*
;

index_type:
   simple_type
;

component_type:
   type
;

type_identifier: 
	names+=ID
   	| (type+='CHAR' | type+='boolean' | type+='integer' | type+='real' | type+='string')
;

string_type:
	'string' '[' ( names+=ID | number+=unsigned_number ) ']'
;

unsigned_constant:
	 number+=unsigned_number
   | char+=constant_chr
   | string+=STRING
   | nil+=NIL
;

unsigned_number: 
	 numbers+=unsigned_integer
   | numbers+=unsigned_real
;

constant_chr:
	"chr" "(" numbers+=unsigned_integer ")"
;

procedure_statement:
	names+=ID ('(' types+=parameter_list ')')?
;

parameter_list:
	actual_parameter (',' types+=actual_parameter)*
; 

actual_parameter :
	expression
;

structured_statement:
	compound_stat+=compound_statement
	| conditional_stat+=conditional_statement
;

conditional_statement:
	cond_statements+=case_statement
;

case_statement:
	"case" exp+=expression "of" case_list+=case_list_element ( ";" case_list+=case_list_element )* ( ";" )? ("else" case_statements+=statements)? "end"
;

case_list_element:
	consts+=const_list ":" case_statement+=statement
;

const_list:
 	constants+=constant ( "," constants+= constant )* 
;

unsigned_integer: 
	NUM_INT
;

unsigned_real: 
	NUM_REAL
;

additive_operator: 
	 PLUS
   | MINUS
   | OR
;

multiplicative_operator
   : STAR
   | SLASH
   | DIV
   | MOD
   | AND
;

relational_operator: 
	 EQUAL
   | NOT_EQUAL
   | LT
   | LE
   | GE
   | GT
   | IN
;

procedure_and_function_declaration_part:
	procedure_or_function_declaration ";"
;

procedure_or_function_declaration:
	procedure_declaration | function_declaration
;

procedure_declaration:
	procedure names+=ID  (types+=formal_parameter_list)? ';' block=block
;

type_definition:
	names+= ID EQUAL (type | function_type | procedure_type)
;

procedure_type: //Add action to ensure object creation?
	 {procedure_type} procedure (types+=formal_parameter_list)?
;

function_declaration:
	function names+=ID (types+=formal_parameter_list)? ':' 
	types+=result_type ';' block=block
;

function_type:
	function (types+=formal_parameter_list)? ':' types+=result_type
;

function_designator:
	names+=ID '(' types+=parameter_list ')'
;


formal_parameter_list:
	'(' formal_parameter_section (';' types+=formal_parameter_section )* ')'
;

formal_parameter_section:
	  parameter_group
	| 'var' parameter_group
	| function parameter_group
	| procedure parameter_group
;

parameter_group:
	identifier_list ":" types+=type_identifier
;

result_type:
	type_identifier
;

bool:
	"true" | "false"
;

procedure:
	'procedure'
;

function:
	'function'
;


sign: 
	 PLUS
   | MINUS
;

@Override // Overrides the ML_COMMENT from "Terminals"
terminal ML_COMMENT :
	'(*' -> '*)' | '{' -> '}'
;

terminal NIL:
	'nil'
;

terminal DOTDOT:
	'..'
;

terminal NOT:
	'not'
;

terminal STAR:
	'*'
;

terminal SLASH:
	'/'
;

terminal DIV:
	'div'
;

terminal MOD:
	'mod'
;

terminal PLUS:
	'+'
;

terminal MINUS:
	'-'
;

terminal AND:
	'and'
;

terminal OR:
	'or'
;

terminal ASSIGN: 
	':='
;

terminal NUM_INT: 
	('0' .. '9') +
;

terminal NUM_REAL: 
	('0' .. '9') + (('.' ('0' .. '9') + (EXPONENT)?)? | EXPONENT)
;

terminal fragment EXPONENT: 
	('e') (PLUS | MINUS)? ('0' .. '9') +
;

terminal EQUAL: 
	'='
;

terminal NOT_EQUAL: 
	'<>'
;

terminal LT: 
	'<'
;

terminal LE: 
	'<='
;

terminal GE: 
	'>='
;

terminal GT: 
	'>'
;

terminal IN:
	'in'	
;