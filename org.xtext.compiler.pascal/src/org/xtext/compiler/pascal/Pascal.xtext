grammar org.xtext.compiler.pascal.Pascal hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate pascal "http://www.xtext.org/compiler/pascal/Pascal"

pascal:
	program = program
; 

program:
	heading=program_heading_block block=block "." 
;

program_heading_block:
	"program" name=ID ";"	
;

identifier_list:
	names+=identifier ( "," names+=identifier ) *	
;

identifier:
	id=ID
;

block:
	(constantpart+=constant_definition_part | 
	 variablepart+=variable_declaration_part | 
	 procedure_function_part+=procedure_and_function_declaration_part
	)* statement=compound_statement
;

constant_definition_part: 
	'const' (constants+=constant_definition ';') +
;

constant_definition: 
	name=ID EQUAL constant
;

constant: 
	 uns_number=unsigned_number
   | sign sig_number=unsigned_number
   | name_id=ID
   | sign sig_name_id=ID
   | string=STRING
   | booltype=bool
;

variable_declaration_part
   : "var" variable+=variable_declaration (";" variable+=variable_declaration)* ";"
;

variable_declaration
   : list_names=identifier_list ":" type_variable=type
;

compound_statement:
	"begin" sequence=statements "end"	
;

statements:
	statements+=statement ( ";" statements+=statement ) *
;

statement:  
	{statement} (statement+=unlabelled_statement) ? 
;

unlabelled_statement:
	simple=simple_statement | structured=structured_statement
;

simple_statement:
	assignment=assignment_statement | procedure=procedure_statement
;

assignment_statement: 
	declared_variable=variable ASSIGN expression=expression	
;

variable
   : ('@' variable_id=ID | variable_id=ID) ('[' expression+=expression ("," expression+=expression)* ']' | "(." expression+=expression ("," expression+=expression)* ".)" | "." names_exp+=ID | "^")*
;

expression:
	simple=simple_expression
;

simple_expression:
	term_exp=term (operator=additive_operator expression=simple_expression)?
;

term: 
	factor=signed_factor (operator=multiplicative_operator term2=term)?
;

signed_factor: 
	(signal=PLUS | signal=MINUS)? factor=factor
;

factor: 
	 variable=variable
   | "(" expression=expression ")"
   | function=function_designator
   | constant=unsigned_constant   
   | NOT not_factor=factor
   | bool_factor=bool
;

type: 
	 simple=simple_type
   //| type=structured_type
;

simple_type: 
   type=type_identifier
;

type_identifier: 
	id=ID
   	| (boolean='boolean' | integer='integer' | string='string')
;

unsigned_constant:
	 number=unsigned_number
   | string=STRING
   | nil=NIL
;

unsigned_number: 
	 numbers=unsigned_integer
;


procedure_statement:
	name_id=ID ('(' types+=parameter_list ')')?
;

parameter_list:
	parameters+=actual_parameter (',' parameters+=actual_parameter)*
; 

actual_parameter :
	expression
;

structured_statement:
	compound_stat=compound_statement
	| conditional_stat=conditional_statement
;

conditional_statement:
	cond_statements=case_statement
;

case_statement:
	"case" exp=expression "of" case_list+=case_list_element ( ";" case_list+=case_list_element )* ( ";" )? ("else" case_statements=statements)? "end"
;

case_list_element:
	consts+=const_list ":" case_statement=statement
;

const_list:
 	constants+=constant ( "," constants+= constant )* 
;

unsigned_integer: 
	NUM_INT
;

additive_operator: 
	 PLUS
   | MINUS
   | OR
;

multiplicative_operator
   : STAR
   | SLASH
   | DIV
   | MOD
   | AND
;

procedure_and_function_declaration_part:
	procedure_or_function_declaration ";"
;

procedure_or_function_declaration:
	procedure_declaration | function_declaration
;

procedure_declaration:
	procedure names+=ID  (types+=formal_parameter_list)? ';' block=block
;

type_definition:
	names+= ID EQUAL (type | function_type | procedure_type)
;

procedure_type: //Add action to ensure object creation?
	 {procedure_type} procedure (types+=formal_parameter_list)?
;

function_declaration:
	function names+=ID (types+=formal_parameter_list)? ':' 
	types+=result_type ';' block=block
;

function_type:
	function (types+=formal_parameter_list)? ':' types+=result_type
;

function_designator:
	names+=ID '(' types+=parameter_list ')'
;


formal_parameter_list:
	'(' formal_parameter_section (';' types+=formal_parameter_section )* ')'
;

formal_parameter_section:
	  parameter_group
	| 'var' parameter_group
	| function parameter_group
	| procedure parameter_group
;

parameter_group:
	identifier_list ":" types+=type_identifier
;

result_type:
	type_identifier
;

bool:
	"true" | "false"
;

procedure:
	'procedure'
;

function:
	'function'
;

sign: 
	 PLUS
   | MINUS
;

terminal NIL:
	'nil'
;

terminal DOTDOT:
	'..'
;

terminal NOT:
	('N'|'n') ('O'|'o') ('T'|'t')	
;

terminal STAR:
	'*'
;

terminal SLASH:
	'/'
;

terminal DIV:
	('D'|'d') ('I'|'i') ('V'|'v')
;

terminal MOD:
	('M'|'m') ('O'|'o') ('D'|'d')
;

terminal PLUS:
	'+'
;

terminal MINUS:
	'-'
;

terminal AND:
	('A'|'a') ('N'|'n') ('D'|'d')
;

terminal OR:
	('O'|'o') ('R'|'r')
;

terminal ASSIGN: 
	':='
;

terminal NUM_INT: 
	('0' .. '9') +
;

terminal EQUAL: 
	'='
;

terminal ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

terminal STRING:			
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
		;
		
terminal ML_COMMENT :
	'(*' -> '*)' | '{' -> '}'
;

terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS         : (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;