/*
 * generated by Xtext 2.15.0
 */
parser grammar InternalPascalParser;

options {
	tokenVocab=InternalPascalLexer;
	superClass=AbstractInternalAntlrParser;
}

@header {
package org.xtext.compiler.pascal.parser.antlr.internal;

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import org.xtext.compiler.pascal.services.PascalGrammarAccess;

}

@members {

 	private PascalGrammarAccess grammarAccess;

    public InternalPascalParser(TokenStream input, PascalGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }

    @Override
    protected String getFirstRuleName() {
    	return "pascal";
   	}

   	@Override
   	protected PascalGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}

}

@rulecatch {
    catch (RecognitionException re) {
        recover(input,re);
        appendSkippedTokens();
    }
}

// Entry rule entryRulepascal
entryRulepascal returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getPascalRule()); }
	iv_rulepascal=rulepascal
	{ $current=$iv_rulepascal.current; }
	EOF;

// Rule pascal
rulepascal returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getPascalAccess().getProgramProgramParserRuleCall_0());
			}
			lv_program_0_0=ruleprogram
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getPascalRule());
				}
				set(
					$current,
					"program",
					lv_program_0_0,
					"org.xtext.compiler.pascal.Pascal.program");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRuleprogram
entryRuleprogram returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getProgramRule()); }
	iv_ruleprogram=ruleprogram
	{ $current=$iv_ruleprogram.current; }
	EOF;

// Rule program
ruleprogram returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getProgramAccess().getHeadingProgram_heading_blockParserRuleCall_0_0());
				}
				lv_heading_0_0=ruleprogram_heading_block
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getProgramRule());
					}
					set(
						$current,
						"heading",
						lv_heading_0_0,
						"org.xtext.compiler.pascal.Pascal.program_heading_block");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getProgramAccess().getBlockBlockParserRuleCall_1_0());
				}
				lv_block_1_0=ruleblock
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getProgramRule());
					}
					set(
						$current,
						"block",
						lv_block_1_0,
						"org.xtext.compiler.pascal.Pascal.block");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_2=FullStop
		{
			newLeafNode(otherlv_2, grammarAccess.getProgramAccess().getFullStopKeyword_2());
		}
	)
;

// Entry rule entryRuleprogram_heading_block
entryRuleprogram_heading_block returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getProgram_heading_blockRule()); }
	iv_ruleprogram_heading_block=ruleprogram_heading_block
	{ $current=$iv_ruleprogram_heading_block.current; }
	EOF;

// Rule program_heading_block
ruleprogram_heading_block returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Program
		{
			newLeafNode(otherlv_0, grammarAccess.getProgram_heading_blockAccess().getProgramKeyword_0());
		}
		(
			(
				lv_name_1_0=RULE_ID
				{
					newLeafNode(lv_name_1_0, grammarAccess.getProgram_heading_blockAccess().getNameIDTerminalRuleCall_1_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getProgram_heading_blockRule());
					}
					setWithLastConsumed(
						$current,
						"name",
						lv_name_1_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		otherlv_2=Semicolon
		{
			newLeafNode(otherlv_2, grammarAccess.getProgram_heading_blockAccess().getSemicolonKeyword_2());
		}
	)
;

// Entry rule entryRuleidentifier_list
entryRuleidentifier_list returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getIdentifier_listRule()); }
	iv_ruleidentifier_list=ruleidentifier_list
	{ $current=$iv_ruleidentifier_list.current; }
	EOF;

// Rule identifier_list
ruleidentifier_list returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getIdentifier_listAccess().getNamesIdentifierParserRuleCall_0_0());
				}
				lv_names_0_0=ruleidentifier
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getIdentifier_listRule());
					}
					add(
						$current,
						"names",
						lv_names_0_0,
						"org.xtext.compiler.pascal.Pascal.identifier");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_1=Comma
			{
				newLeafNode(otherlv_1, grammarAccess.getIdentifier_listAccess().getCommaKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getIdentifier_listAccess().getNamesIdentifierParserRuleCall_1_1_0());
					}
					lv_names_2_0=ruleidentifier
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getIdentifier_listRule());
						}
						add(
							$current,
							"names",
							lv_names_2_0,
							"org.xtext.compiler.pascal.Pascal.identifier");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
	)
;

// Entry rule entryRuleidentifier
entryRuleidentifier returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getIdentifierRule()); }
	iv_ruleidentifier=ruleidentifier
	{ $current=$iv_ruleidentifier.current; }
	EOF;

// Rule identifier
ruleidentifier returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			lv_id_0_0=RULE_ID
			{
				newLeafNode(lv_id_0_0, grammarAccess.getIdentifierAccess().getIdIDTerminalRuleCall_0());
			}
			{
				if ($current==null) {
					$current = createModelElement(grammarAccess.getIdentifierRule());
				}
				setWithLastConsumed(
					$current,
					"id",
					lv_id_0_0,
					"org.xtext.compiler.pascal.Pascal.ID");
			}
		)
	)
;

// Entry rule entryRuleblock
entryRuleblock returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getBlockRule()); }
	iv_ruleblock=ruleblock
	{ $current=$iv_ruleblock.current; }
	EOF;

// Rule block
ruleblock returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getBlockAccess().getConstantpartConstant_definition_partParserRuleCall_0_0_0());
					}
					lv_constantpart_0_0=ruleconstant_definition_part
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getBlockRule());
						}
						add(
							$current,
							"constantpart",
							lv_constantpart_0_0,
							"org.xtext.compiler.pascal.Pascal.constant_definition_part");
						afterParserOrEnumRuleCall();
					}
				)
			)
			    |
			(
				(
					{
						newCompositeNode(grammarAccess.getBlockAccess().getType_partType_definition_partParserRuleCall_0_1_0());
					}
					lv_type_part_1_0=ruletype_definition_part
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getBlockRule());
						}
						add(
							$current,
							"type_part",
							lv_type_part_1_0,
							"org.xtext.compiler.pascal.Pascal.type_definition_part");
						afterParserOrEnumRuleCall();
					}
				)
			)
			    |
			(
				(
					{
						newCompositeNode(grammarAccess.getBlockAccess().getVariablepartVariable_declaration_partParserRuleCall_0_2_0());
					}
					lv_variablepart_2_0=rulevariable_declaration_part
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getBlockRule());
						}
						add(
							$current,
							"variablepart",
							lv_variablepart_2_0,
							"org.xtext.compiler.pascal.Pascal.variable_declaration_part");
						afterParserOrEnumRuleCall();
					}
				)
			)
			    |
			(
				(
					{
						newCompositeNode(grammarAccess.getBlockAccess().getProcedure_function_partProcedure_and_function_declaration_partParserRuleCall_0_3_0());
					}
					lv_procedure_function_part_3_0=ruleprocedure_and_function_declaration_part
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getBlockRule());
						}
						add(
							$current,
							"procedure_function_part",
							lv_procedure_function_part_3_0,
							"org.xtext.compiler.pascal.Pascal.procedure_and_function_declaration_part");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
		(
			(
				{
					newCompositeNode(grammarAccess.getBlockAccess().getStatementCompound_statementParserRuleCall_1_0());
				}
				lv_statement_4_0=rulecompound_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getBlockRule());
					}
					set(
						$current,
						"statement",
						lv_statement_4_0,
						"org.xtext.compiler.pascal.Pascal.compound_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleconstant_definition_part
entryRuleconstant_definition_part returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getConstant_definition_partRule()); }
	iv_ruleconstant_definition_part=ruleconstant_definition_part
	{ $current=$iv_ruleconstant_definition_part.current; }
	EOF;

// Rule constant_definition_part
ruleconstant_definition_part returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Const
		{
			newLeafNode(otherlv_0, grammarAccess.getConstant_definition_partAccess().getConstKeyword_0());
		}
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getConstant_definition_partAccess().getConstantsConstant_definitionParserRuleCall_1_0_0());
					}
					lv_constants_1_0=ruleconstant_definition
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getConstant_definition_partRule());
						}
						add(
							$current,
							"constants",
							lv_constants_1_0,
							"org.xtext.compiler.pascal.Pascal.constant_definition");
						afterParserOrEnumRuleCall();
					}
				)
			)
			otherlv_2=Semicolon
			{
				newLeafNode(otherlv_2, grammarAccess.getConstant_definition_partAccess().getSemicolonKeyword_1_1());
			}
		)+
	)
;

// Entry rule entryRuleconstant_definition
entryRuleconstant_definition returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getConstant_definitionRule()); }
	iv_ruleconstant_definition=ruleconstant_definition
	{ $current=$iv_ruleconstant_definition.current; }
	EOF;

// Rule constant_definition
ruleconstant_definition returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_name_0_0=RULE_ID
				{
					newLeafNode(lv_name_0_0, grammarAccess.getConstant_definitionAccess().getNameIDTerminalRuleCall_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getConstant_definitionRule());
					}
					setWithLastConsumed(
						$current,
						"name",
						lv_name_0_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		this_EQUAL_1=RULE_EQUAL
		{
			newLeafNode(this_EQUAL_1, grammarAccess.getConstant_definitionAccess().getEQUALTerminalRuleCall_1());
		}
		{
			newCompositeNode(grammarAccess.getConstant_definitionAccess().getConstantParserRuleCall_2());
		}
		this_constant_2=ruleconstant
		{
			$current = $this_constant_2.current;
			afterParserOrEnumRuleCall();
		}
	)
;

// Entry rule entryRuleconstant
entryRuleconstant returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getConstantRule()); }
	iv_ruleconstant=ruleconstant
	{ $current=$iv_ruleconstant.current; }
	EOF;

// Rule constant
ruleconstant returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getConstantAccess().getUns_numberUnsigned_numberParserRuleCall_0_0());
				}
				lv_uns_number_0_0=ruleunsigned_number
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getConstantRule());
					}
					set(
						$current,
						"uns_number",
						lv_uns_number_0_0,
						"org.xtext.compiler.pascal.Pascal.unsigned_number");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			{
				newCompositeNode(grammarAccess.getConstantAccess().getSignParserRuleCall_1_0());
			}
			rulesign
			{
				afterParserOrEnumRuleCall();
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getConstantAccess().getSig_numberUnsigned_numberParserRuleCall_1_1_0());
					}
					lv_sig_number_2_0=ruleunsigned_number
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getConstantRule());
						}
						set(
							$current,
							"sig_number",
							lv_sig_number_2_0,
							"org.xtext.compiler.pascal.Pascal.unsigned_number");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)
		    |
		(
			(
				lv_name_id_3_0=RULE_ID
				{
					newLeafNode(lv_name_id_3_0, grammarAccess.getConstantAccess().getName_idIDTerminalRuleCall_2_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getConstantRule());
					}
					setWithLastConsumed(
						$current,
						"name_id",
						lv_name_id_3_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		    |
		(
			{
				newCompositeNode(grammarAccess.getConstantAccess().getSignParserRuleCall_3_0());
			}
			rulesign
			{
				afterParserOrEnumRuleCall();
			}
			(
				(
					lv_sig_name_id_5_0=RULE_ID
					{
						newLeafNode(lv_sig_name_id_5_0, grammarAccess.getConstantAccess().getSig_name_idIDTerminalRuleCall_3_1_0());
					}
					{
						if ($current==null) {
							$current = createModelElement(grammarAccess.getConstantRule());
						}
						setWithLastConsumed(
							$current,
							"sig_name_id",
							lv_sig_name_id_5_0,
							"org.xtext.compiler.pascal.Pascal.ID");
					}
				)
			)
		)
		    |
		(
			(
				lv_string_6_0=RULE_STRING
				{
					newLeafNode(lv_string_6_0, grammarAccess.getConstantAccess().getStringSTRINGTerminalRuleCall_4_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getConstantRule());
					}
					setWithLastConsumed(
						$current,
						"string",
						lv_string_6_0,
						"org.xtext.compiler.pascal.Pascal.STRING");
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getConstantAccess().getBooltypeBoolParserRuleCall_5_0());
				}
				lv_booltype_7_0=rulebool
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getConstantRule());
					}
					set(
						$current,
						"booltype",
						lv_booltype_7_0,
						"org.xtext.compiler.pascal.Pascal.bool");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuletype_definition_part
entryRuletype_definition_part returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getType_definition_partRule()); }
	iv_ruletype_definition_part=ruletype_definition_part
	{ $current=$iv_ruletype_definition_part.current; }
	EOF;

// Rule type_definition_part
ruletype_definition_part returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Type
		{
			newLeafNode(otherlv_0, grammarAccess.getType_definition_partAccess().getTypeKeyword_0());
		}
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getType_definition_partAccess().getTypesType_definitionParserRuleCall_1_0_0());
					}
					lv_types_1_0=ruletype_definition
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getType_definition_partRule());
						}
						add(
							$current,
							"types",
							lv_types_1_0,
							"org.xtext.compiler.pascal.Pascal.type_definition");
						afterParserOrEnumRuleCall();
					}
				)
			)
			otherlv_2=Semicolon
			{
				newLeafNode(otherlv_2, grammarAccess.getType_definition_partAccess().getSemicolonKeyword_1_1());
			}
		)+
	)
;

// Entry rule entryRuletype_definition
entryRuletype_definition returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getType_definitionRule()); }
	iv_ruletype_definition=ruletype_definition
	{ $current=$iv_ruletype_definition.current; }
	EOF;

// Rule type_definition
ruletype_definition returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_name_0_0=RULE_ID
				{
					newLeafNode(lv_name_0_0, grammarAccess.getType_definitionAccess().getNameIDTerminalRuleCall_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getType_definitionRule());
					}
					setWithLastConsumed(
						$current,
						"name",
						lv_name_0_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		this_EQUAL_1=RULE_EQUAL
		{
			newLeafNode(this_EQUAL_1, grammarAccess.getType_definitionAccess().getEQUALTerminalRuleCall_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getType_definitionAccess().getTypeTypeParserRuleCall_2_0());
				}
				lv_type_2_0=ruletype
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getType_definitionRule());
					}
					set(
						$current,
						"type",
						lv_type_2_0,
						"org.xtext.compiler.pascal.Pascal.type");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulevariable_declaration_part
entryRulevariable_declaration_part returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getVariable_declaration_partRule()); }
	iv_rulevariable_declaration_part=rulevariable_declaration_part
	{ $current=$iv_rulevariable_declaration_part.current; }
	EOF;

// Rule variable_declaration_part
rulevariable_declaration_part returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Var
		{
			newLeafNode(otherlv_0, grammarAccess.getVariable_declaration_partAccess().getVarKeyword_0());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getVariable_declaration_partAccess().getVariableVariable_declarationParserRuleCall_1_0());
				}
				lv_variable_1_0=rulevariable_declaration
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getVariable_declaration_partRule());
					}
					add(
						$current,
						"variable",
						lv_variable_1_0,
						"org.xtext.compiler.pascal.Pascal.variable_declaration");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_2=Semicolon
			{
				newLeafNode(otherlv_2, grammarAccess.getVariable_declaration_partAccess().getSemicolonKeyword_2_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getVariable_declaration_partAccess().getVariableVariable_declarationParserRuleCall_2_1_0());
					}
					lv_variable_3_0=rulevariable_declaration
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getVariable_declaration_partRule());
						}
						add(
							$current,
							"variable",
							lv_variable_3_0,
							"org.xtext.compiler.pascal.Pascal.variable_declaration");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
		otherlv_4=Semicolon
		{
			newLeafNode(otherlv_4, grammarAccess.getVariable_declaration_partAccess().getSemicolonKeyword_3());
		}
	)
;

// Entry rule entryRulevariable_declaration
entryRulevariable_declaration returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getVariable_declarationRule()); }
	iv_rulevariable_declaration=rulevariable_declaration
	{ $current=$iv_rulevariable_declaration.current; }
	EOF;

// Rule variable_declaration
rulevariable_declaration returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getVariable_declarationAccess().getList_namesIdentifier_listParserRuleCall_0_0());
				}
				lv_list_names_0_0=ruleidentifier_list
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getVariable_declarationRule());
					}
					set(
						$current,
						"list_names",
						lv_list_names_0_0,
						"org.xtext.compiler.pascal.Pascal.identifier_list");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_1=Colon
		{
			newLeafNode(otherlv_1, grammarAccess.getVariable_declarationAccess().getColonKeyword_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getVariable_declarationAccess().getType_variableTypeParserRuleCall_2_0());
				}
				lv_type_variable_2_0=ruletype
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getVariable_declarationRule());
					}
					set(
						$current,
						"type_variable",
						lv_type_variable_2_0,
						"org.xtext.compiler.pascal.Pascal.type");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulecompound_statement
entryRulecompound_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getCompound_statementRule()); }
	iv_rulecompound_statement=rulecompound_statement
	{ $current=$iv_rulecompound_statement.current; }
	EOF;

// Rule compound_statement
rulecompound_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Begin
		{
			newLeafNode(otherlv_0, grammarAccess.getCompound_statementAccess().getBeginKeyword_0());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getCompound_statementAccess().getSequenceStatementsParserRuleCall_1_0());
				}
				lv_sequence_1_0=rulestatements
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getCompound_statementRule());
					}
					set(
						$current,
						"sequence",
						lv_sequence_1_0,
						"org.xtext.compiler.pascal.Pascal.statements");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_2=End
		{
			newLeafNode(otherlv_2, grammarAccess.getCompound_statementAccess().getEndKeyword_2());
		}
	)
;

// Entry rule entryRulestatements
entryRulestatements returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getStatementsRule()); }
	iv_rulestatements=rulestatements
	{ $current=$iv_rulestatements.current; }
	EOF;

// Rule statements
rulestatements returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getStatementsAccess().getStatementsStatementParserRuleCall_0_0());
				}
				lv_statements_0_0=rulestatement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getStatementsRule());
					}
					add(
						$current,
						"statements",
						lv_statements_0_0,
						"org.xtext.compiler.pascal.Pascal.statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_1=Semicolon
			{
				newLeafNode(otherlv_1, grammarAccess.getStatementsAccess().getSemicolonKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getStatementsAccess().getStatementsStatementParserRuleCall_1_1_0());
					}
					lv_statements_2_0=rulestatement
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getStatementsRule());
						}
						add(
							$current,
							"statements",
							lv_statements_2_0,
							"org.xtext.compiler.pascal.Pascal.statement");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
	)
;

// Entry rule entryRulestatement
entryRulestatement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getStatementRule()); }
	iv_rulestatement=rulestatement
	{ $current=$iv_rulestatement.current; }
	EOF;

// Rule statement
rulestatement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				$current = forceCreateModelElement(
					grammarAccess.getStatementAccess().getStatementAction_0(),
					$current);
			}
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getStatementAccess().getStatementUnlabelled_statementParserRuleCall_1_0());
				}
				lv_statement_1_0=ruleunlabelled_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getStatementRule());
					}
					add(
						$current,
						"statement",
						lv_statement_1_0,
						"org.xtext.compiler.pascal.Pascal.unlabelled_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)?
	)
;

// Entry rule entryRuleunlabelled_statement
entryRuleunlabelled_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getUnlabelled_statementRule()); }
	iv_ruleunlabelled_statement=ruleunlabelled_statement
	{ $current=$iv_ruleunlabelled_statement.current; }
	EOF;

// Rule unlabelled_statement
ruleunlabelled_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getUnlabelled_statementAccess().getSimpleSimple_statementParserRuleCall_0_0());
				}
				lv_simple_0_0=rulesimple_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getUnlabelled_statementRule());
					}
					set(
						$current,
						"simple",
						lv_simple_0_0,
						"org.xtext.compiler.pascal.Pascal.simple_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getUnlabelled_statementAccess().getStructuredStructured_statementParserRuleCall_1_0());
				}
				lv_structured_1_0=rulestructured_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getUnlabelled_statementRule());
					}
					set(
						$current,
						"structured",
						lv_structured_1_0,
						"org.xtext.compiler.pascal.Pascal.structured_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulesimple_statement
entryRulesimple_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getSimple_statementRule()); }
	iv_rulesimple_statement=rulesimple_statement
	{ $current=$iv_rulesimple_statement.current; }
	EOF;

// Rule simple_statement
rulesimple_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getSimple_statementAccess().getAssignmentAssignment_statementParserRuleCall_0_0());
				}
				lv_assignment_0_0=ruleassignment_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSimple_statementRule());
					}
					set(
						$current,
						"assignment",
						lv_assignment_0_0,
						"org.xtext.compiler.pascal.Pascal.assignment_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getSimple_statementAccess().getProcedureProcedure_statementParserRuleCall_1_0());
				}
				lv_procedure_1_0=ruleprocedure_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSimple_statementRule());
					}
					set(
						$current,
						"procedure",
						lv_procedure_1_0,
						"org.xtext.compiler.pascal.Pascal.procedure_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleassignment_statement
entryRuleassignment_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getAssignment_statementRule()); }
	iv_ruleassignment_statement=ruleassignment_statement
	{ $current=$iv_ruleassignment_statement.current; }
	EOF;

// Rule assignment_statement
ruleassignment_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getAssignment_statementAccess().getDeclared_variableVariableParserRuleCall_0_0());
				}
				lv_declared_variable_0_0=rulevariable
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getAssignment_statementRule());
					}
					set(
						$current,
						"declared_variable",
						lv_declared_variable_0_0,
						"org.xtext.compiler.pascal.Pascal.variable");
					afterParserOrEnumRuleCall();
				}
			)
		)
		this_ASSIGN_1=RULE_ASSIGN
		{
			newLeafNode(this_ASSIGN_1, grammarAccess.getAssignment_statementAccess().getASSIGNTerminalRuleCall_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getAssignment_statementAccess().getExpressionExpressionParserRuleCall_2_0());
				}
				lv_expression_2_0=ruleexpression
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getAssignment_statementRule());
					}
					set(
						$current,
						"expression",
						lv_expression_2_0,
						"org.xtext.compiler.pascal.Pascal.expression");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulevariable
entryRulevariable returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getVariableRule()); }
	iv_rulevariable=rulevariable
	{ $current=$iv_rulevariable.current; }
	EOF;

// Rule variable
rulevariable returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				otherlv_0=CommercialAt
				{
					newLeafNode(otherlv_0, grammarAccess.getVariableAccess().getCommercialAtKeyword_0_0_0());
				}
				(
					(
						lv_variable_id_1_0=RULE_ID
						{
							newLeafNode(lv_variable_id_1_0, grammarAccess.getVariableAccess().getVariable_idIDTerminalRuleCall_0_0_1_0());
						}
						{
							if ($current==null) {
								$current = createModelElement(grammarAccess.getVariableRule());
							}
							setWithLastConsumed(
								$current,
								"variable_id",
								lv_variable_id_1_0,
								"org.xtext.compiler.pascal.Pascal.ID");
						}
					)
				)
			)
			    |
			(
				(
					lv_variable_id_2_0=RULE_ID
					{
						newLeafNode(lv_variable_id_2_0, grammarAccess.getVariableAccess().getVariable_idIDTerminalRuleCall_0_1_0());
					}
					{
						if ($current==null) {
							$current = createModelElement(grammarAccess.getVariableRule());
						}
						setWithLastConsumed(
							$current,
							"variable_id",
							lv_variable_id_2_0,
							"org.xtext.compiler.pascal.Pascal.ID");
					}
				)
			)
		)
		(
			(
				otherlv_3=LeftSquareBracket
				{
					newLeafNode(otherlv_3, grammarAccess.getVariableAccess().getLeftSquareBracketKeyword_1_0_0());
				}
				(
					(
						{
							newCompositeNode(grammarAccess.getVariableAccess().getIndiceExpressionParserRuleCall_1_0_1_0());
						}
						lv_indice_4_0=ruleexpression
						{
							if ($current==null) {
								$current = createModelElementForParent(grammarAccess.getVariableRule());
							}
							add(
								$current,
								"indice",
								lv_indice_4_0,
								"org.xtext.compiler.pascal.Pascal.expression");
							afterParserOrEnumRuleCall();
						}
					)
				)
				(
					otherlv_5=Comma
					{
						newLeafNode(otherlv_5, grammarAccess.getVariableAccess().getCommaKeyword_1_0_2_0());
					}
					(
						(
							{
								newCompositeNode(grammarAccess.getVariableAccess().getIndiceExpressionParserRuleCall_1_0_2_1_0());
							}
							lv_indice_6_0=ruleexpression
							{
								if ($current==null) {
									$current = createModelElementForParent(grammarAccess.getVariableRule());
								}
								add(
									$current,
									"indice",
									lv_indice_6_0,
									"org.xtext.compiler.pascal.Pascal.expression");
								afterParserOrEnumRuleCall();
							}
						)
					)
				)*
				otherlv_7=RightSquareBracket
				{
					newLeafNode(otherlv_7, grammarAccess.getVariableAccess().getRightSquareBracketKeyword_1_0_3());
				}
			)
			    |
			(
				otherlv_8=LeftParenthesisFullStop
				{
					newLeafNode(otherlv_8, grammarAccess.getVariableAccess().getLeftParenthesisFullStopKeyword_1_1_0());
				}
				(
					(
						{
							newCompositeNode(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_1_1_1_0());
						}
						lv_expression_9_0=ruleexpression
						{
							if ($current==null) {
								$current = createModelElementForParent(grammarAccess.getVariableRule());
							}
							add(
								$current,
								"expression",
								lv_expression_9_0,
								"org.xtext.compiler.pascal.Pascal.expression");
							afterParserOrEnumRuleCall();
						}
					)
				)
				(
					otherlv_10=Comma
					{
						newLeafNode(otherlv_10, grammarAccess.getVariableAccess().getCommaKeyword_1_1_2_0());
					}
					(
						(
							{
								newCompositeNode(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_1_1_2_1_0());
							}
							lv_expression_11_0=ruleexpression
							{
								if ($current==null) {
									$current = createModelElementForParent(grammarAccess.getVariableRule());
								}
								add(
									$current,
									"expression",
									lv_expression_11_0,
									"org.xtext.compiler.pascal.Pascal.expression");
								afterParserOrEnumRuleCall();
							}
						)
					)
				)*
				otherlv_12=FullStopRightParenthesis
				{
					newLeafNode(otherlv_12, grammarAccess.getVariableAccess().getFullStopRightParenthesisKeyword_1_1_3());
				}
			)
			    |
			(
				otherlv_13=FullStop
				{
					newLeafNode(otherlv_13, grammarAccess.getVariableAccess().getFullStopKeyword_1_2_0());
				}
				(
					(
						lv_names_exp_14_0=RULE_ID
						{
							newLeafNode(lv_names_exp_14_0, grammarAccess.getVariableAccess().getNames_expIDTerminalRuleCall_1_2_1_0());
						}
						{
							if ($current==null) {
								$current = createModelElement(grammarAccess.getVariableRule());
							}
							addWithLastConsumed(
								$current,
								"names_exp",
								lv_names_exp_14_0,
								"org.xtext.compiler.pascal.Pascal.ID");
						}
					)
				)
			)
			    |
			otherlv_15=CircumflexAccent
			{
				newLeafNode(otherlv_15, grammarAccess.getVariableAccess().getCircumflexAccentKeyword_1_3());
			}
		)*
	)
;

// Entry rule entryRuleexpression
entryRuleexpression returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getExpressionRule()); }
	iv_ruleexpression=ruleexpression
	{ $current=$iv_ruleexpression.current; }
	EOF;

// Rule expression
ruleexpression returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getExpressionAccess().getSimpleSimple_expressionParserRuleCall_0());
			}
			lv_simple_0_0=rulesimple_expression
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getExpressionRule());
				}
				set(
					$current,
					"simple",
					lv_simple_0_0,
					"org.xtext.compiler.pascal.Pascal.simple_expression");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRulesimple_expression
entryRulesimple_expression returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getSimple_expressionRule()); }
	iv_rulesimple_expression=rulesimple_expression
	{ $current=$iv_rulesimple_expression.current; }
	EOF;

// Rule simple_expression
rulesimple_expression returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getSimple_expressionAccess().getTerm_expTermParserRuleCall_0_0());
				}
				lv_term_exp_0_0=ruleterm
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSimple_expressionRule());
					}
					set(
						$current,
						"term_exp",
						lv_term_exp_0_0,
						"org.xtext.compiler.pascal.Pascal.term");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getSimple_expressionAccess().getOperatorAdditive_operatorParserRuleCall_1_0_0());
					}
					lv_operator_1_0=ruleadditive_operator
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getSimple_expressionRule());
						}
						set(
							$current,
							"operator",
							lv_operator_1_0,
							"org.xtext.compiler.pascal.Pascal.additive_operator");
						afterParserOrEnumRuleCall();
					}
				)
			)
			(
				(
					{
						newCompositeNode(grammarAccess.getSimple_expressionAccess().getExpressionSimple_expressionParserRuleCall_1_1_0());
					}
					lv_expression_2_0=rulesimple_expression
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getSimple_expressionRule());
						}
						set(
							$current,
							"expression",
							lv_expression_2_0,
							"org.xtext.compiler.pascal.Pascal.simple_expression");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)?
	)
;

// Entry rule entryRuleterm
entryRuleterm returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getTermRule()); }
	iv_ruleterm=ruleterm
	{ $current=$iv_ruleterm.current; }
	EOF;

// Rule term
ruleterm returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getTermAccess().getFactorSigned_factorParserRuleCall_0_0());
				}
				lv_factor_0_0=rulesigned_factor
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getTermRule());
					}
					set(
						$current,
						"factor",
						lv_factor_0_0,
						"org.xtext.compiler.pascal.Pascal.signed_factor");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getTermAccess().getOperatorMultiplicative_operatorParserRuleCall_1_0_0());
					}
					lv_operator_1_0=rulemultiplicative_operator
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getTermRule());
						}
						set(
							$current,
							"operator",
							lv_operator_1_0,
							"org.xtext.compiler.pascal.Pascal.multiplicative_operator");
						afterParserOrEnumRuleCall();
					}
				)
			)
			(
				(
					{
						newCompositeNode(grammarAccess.getTermAccess().getTerm2TermParserRuleCall_1_1_0());
					}
					lv_term2_2_0=ruleterm
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getTermRule());
						}
						set(
							$current,
							"term2",
							lv_term2_2_0,
							"org.xtext.compiler.pascal.Pascal.term");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)?
	)
;

// Entry rule entryRulesigned_factor
entryRulesigned_factor returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getSigned_factorRule()); }
	iv_rulesigned_factor=rulesigned_factor
	{ $current=$iv_rulesigned_factor.current; }
	EOF;

// Rule signed_factor
rulesigned_factor returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				(
					lv_signal_0_0=RULE_PLUS
					{
						newLeafNode(lv_signal_0_0, grammarAccess.getSigned_factorAccess().getSignalPLUSTerminalRuleCall_0_0_0());
					}
					{
						if ($current==null) {
							$current = createModelElement(grammarAccess.getSigned_factorRule());
						}
						setWithLastConsumed(
							$current,
							"signal",
							lv_signal_0_0,
							"org.xtext.compiler.pascal.Pascal.PLUS");
					}
				)
			)
			    |
			(
				(
					lv_signal_1_0=RULE_MINUS
					{
						newLeafNode(lv_signal_1_0, grammarAccess.getSigned_factorAccess().getSignalMINUSTerminalRuleCall_0_1_0());
					}
					{
						if ($current==null) {
							$current = createModelElement(grammarAccess.getSigned_factorRule());
						}
						setWithLastConsumed(
							$current,
							"signal",
							lv_signal_1_0,
							"org.xtext.compiler.pascal.Pascal.MINUS");
					}
				)
			)
		)?
		(
			(
				{
					newCompositeNode(grammarAccess.getSigned_factorAccess().getFactorFactorParserRuleCall_1_0());
				}
				lv_factor_2_0=rulefactor
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSigned_factorRule());
					}
					set(
						$current,
						"factor",
						lv_factor_2_0,
						"org.xtext.compiler.pascal.Pascal.factor");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulefactor
entryRulefactor returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getFactorRule()); }
	iv_rulefactor=rulefactor
	{ $current=$iv_rulefactor.current; }
	EOF;

// Rule factor
rulefactor returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getFactorAccess().getVariableVariableParserRuleCall_0_0());
				}
				lv_variable_0_0=rulevariable
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFactorRule());
					}
					set(
						$current,
						"variable",
						lv_variable_0_0,
						"org.xtext.compiler.pascal.Pascal.variable");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			otherlv_1=LeftParenthesis
			{
				newLeafNode(otherlv_1, grammarAccess.getFactorAccess().getLeftParenthesisKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getFactorAccess().getExpressionExpressionParserRuleCall_1_1_0());
					}
					lv_expression_2_0=ruleexpression
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFactorRule());
						}
						set(
							$current,
							"expression",
							lv_expression_2_0,
							"org.xtext.compiler.pascal.Pascal.expression");
						afterParserOrEnumRuleCall();
					}
				)
			)
			otherlv_3=RightParenthesis
			{
				newLeafNode(otherlv_3, grammarAccess.getFactorAccess().getRightParenthesisKeyword_1_2());
			}
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getFactorAccess().getFunctionFunction_designatorParserRuleCall_2_0());
				}
				lv_function_4_0=rulefunction_designator
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFactorRule());
					}
					set(
						$current,
						"function",
						lv_function_4_0,
						"org.xtext.compiler.pascal.Pascal.function_designator");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getFactorAccess().getConstantUnsigned_constantParserRuleCall_3_0());
				}
				lv_constant_5_0=ruleunsigned_constant
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFactorRule());
					}
					set(
						$current,
						"constant",
						lv_constant_5_0,
						"org.xtext.compiler.pascal.Pascal.unsigned_constant");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			this_NOT_6=RULE_NOT
			{
				newLeafNode(this_NOT_6, grammarAccess.getFactorAccess().getNOTTerminalRuleCall_4_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getFactorAccess().getNot_factorFactorParserRuleCall_4_1_0());
					}
					lv_not_factor_7_0=rulefactor
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFactorRule());
						}
						set(
							$current,
							"not_factor",
							lv_not_factor_7_0,
							"org.xtext.compiler.pascal.Pascal.factor");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getFactorAccess().getBool_factorBoolParserRuleCall_5_0());
				}
				lv_bool_factor_8_0=rulebool
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFactorRule());
					}
					set(
						$current,
						"bool_factor",
						lv_bool_factor_8_0,
						"org.xtext.compiler.pascal.Pascal.bool");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuletype
entryRuletype returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getTypeRule()); }
	iv_ruletype=ruletype
	{ $current=$iv_ruletype.current; }
	EOF;

// Rule type
ruletype returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getTypeAccess().getSimpleSimple_typeParserRuleCall_0_0());
				}
				lv_simple_0_0=rulesimple_type
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getTypeRule());
					}
					set(
						$current,
						"simple",
						lv_simple_0_0,
						"org.xtext.compiler.pascal.Pascal.simple_type");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getTypeAccess().getStructuredStructured_typeParserRuleCall_1_0());
				}
				lv_structured_1_0=rulestructured_type
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getTypeRule());
					}
					set(
						$current,
						"structured",
						lv_structured_1_0,
						"org.xtext.compiler.pascal.Pascal.structured_type");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulesimple_type
entryRulesimple_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getSimple_typeRule()); }
	iv_rulesimple_type=rulesimple_type
	{ $current=$iv_rulesimple_type.current; }
	EOF;

// Rule simple_type
rulesimple_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getSimple_typeAccess().getTypeType_identifierParserRuleCall_0_0());
				}
				lv_type_0_0=ruletype_identifier
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSimple_typeRule());
					}
					set(
						$current,
						"type",
						lv_type_0_0,
						"org.xtext.compiler.pascal.Pascal.type_identifier");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getSimple_typeAccess().getSubrange_typeSubrange_typeParserRuleCall_1_0());
				}
				lv_subrange_type_1_0=rulesubrange_type
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSimple_typeRule());
					}
					add(
						$current,
						"subrange_type",
						lv_subrange_type_1_0,
						"org.xtext.compiler.pascal.Pascal.subrange_type");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulesubrange_type
entryRulesubrange_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getSubrange_typeRule()); }
	iv_rulesubrange_type=rulesubrange_type
	{ $current=$iv_rulesubrange_type.current; }
	EOF;

// Rule subrange_type
rulesubrange_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getSubrange_typeAccess().getConstantInitConstantParserRuleCall_0_0());
				}
				lv_constantInit_0_0=ruleconstant
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSubrange_typeRule());
					}
					set(
						$current,
						"constantInit",
						lv_constantInit_0_0,
						"org.xtext.compiler.pascal.Pascal.constant");
					afterParserOrEnumRuleCall();
				}
			)
		)
		this_DOTDOT_1=RULE_DOTDOT
		{
			newLeafNode(this_DOTDOT_1, grammarAccess.getSubrange_typeAccess().getDOTDOTTerminalRuleCall_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getSubrange_typeAccess().getConstantFinalConstantParserRuleCall_2_0());
				}
				lv_constantFinal_2_0=ruleconstant
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getSubrange_typeRule());
					}
					set(
						$current,
						"constantFinal",
						lv_constantFinal_2_0,
						"org.xtext.compiler.pascal.Pascal.constant");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulestructured_type
entryRulestructured_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getStructured_typeRule()); }
	iv_rulestructured_type=rulestructured_type
	{ $current=$iv_rulestructured_type.current; }
	EOF;

// Rule structured_type
rulestructured_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getStructured_typeAccess().getUnpackedUnpacked_structured_typeParserRuleCall_0());
			}
			lv_unpacked_0_0=ruleunpacked_structured_type
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getStructured_typeRule());
				}
				set(
					$current,
					"unpacked",
					lv_unpacked_0_0,
					"org.xtext.compiler.pascal.Pascal.unpacked_structured_type");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRuleunpacked_structured_type
entryRuleunpacked_structured_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getUnpacked_structured_typeRule()); }
	iv_ruleunpacked_structured_type=ruleunpacked_structured_type
	{ $current=$iv_ruleunpacked_structured_type.current; }
	EOF;

// Rule unpacked_structured_type
ruleunpacked_structured_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getUnpacked_structured_typeAccess().getStatic_arrayArray_typeParserRuleCall_0_0());
				}
				lv_static_array_0_0=rulearray_type
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getUnpacked_structured_typeRule());
					}
					set(
						$current,
						"static_array",
						lv_static_array_0_0,
						"org.xtext.compiler.pascal.Pascal.array_type");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getUnpacked_structured_typeAccess().getDynamicDynamic_array_typeParserRuleCall_1_0());
				}
				lv_dynamic_1_0=ruledynamic_array_type
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getUnpacked_structured_typeRule());
					}
					set(
						$current,
						"dynamic",
						lv_dynamic_1_0,
						"org.xtext.compiler.pascal.Pascal.dynamic_array_type");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuledynamic_array_type
entryRuledynamic_array_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getDynamic_array_typeRule()); }
	iv_ruledynamic_array_type=ruledynamic_array_type
	{ $current=$iv_ruledynamic_array_type.current; }
	EOF;

// Rule dynamic_array_type
ruledynamic_array_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Array
		{
			newLeafNode(otherlv_0, grammarAccess.getDynamic_array_typeAccess().getArrayKeyword_0());
		}
		otherlv_1=Of
		{
			newLeafNode(otherlv_1, grammarAccess.getDynamic_array_typeAccess().getOfKeyword_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getDynamic_array_typeAccess().getTypeType_identifierParserRuleCall_2_0());
				}
				lv_type_2_0=ruletype_identifier
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getDynamic_array_typeRule());
					}
					set(
						$current,
						"type",
						lv_type_2_0,
						"org.xtext.compiler.pascal.Pascal.type_identifier");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulearray_type
entryRulearray_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getArray_typeRule()); }
	iv_rulearray_type=rulearray_type
	{ $current=$iv_rulearray_type.current; }
	EOF;

// Rule array_type
rulearray_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Array
		{
			newLeafNode(otherlv_0, grammarAccess.getArray_typeAccess().getArrayKeyword_0());
		}
		otherlv_1=LeftSquareBracket
		{
			newLeafNode(otherlv_1, grammarAccess.getArray_typeAccess().getLeftSquareBracketKeyword_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getArray_typeAccess().getType_lType_listParserRuleCall_2_0());
				}
				lv_type_l_2_0=ruletype_list
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getArray_typeRule());
					}
					set(
						$current,
						"type_l",
						lv_type_l_2_0,
						"org.xtext.compiler.pascal.Pascal.type_list");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_3=RightSquareBracket
		{
			newLeafNode(otherlv_3, grammarAccess.getArray_typeAccess().getRightSquareBracketKeyword_3());
		}
		otherlv_4=Of
		{
			newLeafNode(otherlv_4, grammarAccess.getArray_typeAccess().getOfKeyword_4());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getArray_typeAccess().getTypeType_identifierParserRuleCall_5_0());
				}
				lv_type_5_0=ruletype_identifier
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getArray_typeRule());
					}
					set(
						$current,
						"type",
						lv_type_5_0,
						"org.xtext.compiler.pascal.Pascal.type_identifier");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuletype_list
entryRuletype_list returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getType_listRule()); }
	iv_ruletype_list=ruletype_list
	{ $current=$iv_ruletype_list.current; }
	EOF;

// Rule type_list
ruletype_list returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getType_listAccess().getIndexesIndex_typeParserRuleCall_0_0());
				}
				lv_indexes_0_0=ruleindex_type
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getType_listRule());
					}
					add(
						$current,
						"indexes",
						lv_indexes_0_0,
						"org.xtext.compiler.pascal.Pascal.index_type");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_1=Comma
			{
				newLeafNode(otherlv_1, grammarAccess.getType_listAccess().getCommaKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getType_listAccess().getIndexesIndex_typeParserRuleCall_1_1_0());
					}
					lv_indexes_2_0=ruleindex_type
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getType_listRule());
						}
						add(
							$current,
							"indexes",
							lv_indexes_2_0,
							"org.xtext.compiler.pascal.Pascal.index_type");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
	)
;

// Entry rule entryRuleindex_type
entryRuleindex_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getIndex_typeRule()); }
	iv_ruleindex_type=ruleindex_type
	{ $current=$iv_ruleindex_type.current; }
	EOF;

// Rule index_type
ruleindex_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getIndex_typeAccess().getContentSimple_typeParserRuleCall_0());
			}
			lv_content_0_0=rulesimple_type
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getIndex_typeRule());
				}
				set(
					$current,
					"content",
					lv_content_0_0,
					"org.xtext.compiler.pascal.Pascal.simple_type");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRuletype_identifier
entryRuletype_identifier returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getType_identifierRule()); }
	iv_ruletype_identifier=ruletype_identifier
	{ $current=$iv_ruletype_identifier.current; }
	EOF;

// Rule type_identifier
ruletype_identifier returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_id_0_0=RULE_ID
				{
					newLeafNode(lv_id_0_0, grammarAccess.getType_identifierAccess().getIdIDTerminalRuleCall_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getType_identifierRule());
					}
					setWithLastConsumed(
						$current,
						"id",
						lv_id_0_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		    |
		(
			(
				(
					lv_boolean_1_0=Boolean
					{
						newLeafNode(lv_boolean_1_0, grammarAccess.getType_identifierAccess().getBooleanBooleanKeyword_1_0_0());
					}
					{
						if ($current==null) {
							$current = createModelElement(grammarAccess.getType_identifierRule());
						}
						setWithLastConsumed($current, "boolean", lv_boolean_1_0, "boolean");
					}
				)
			)
			    |
			(
				(
					lv_integer_2_0=Integer
					{
						newLeafNode(lv_integer_2_0, grammarAccess.getType_identifierAccess().getIntegerIntegerKeyword_1_1_0());
					}
					{
						if ($current==null) {
							$current = createModelElement(grammarAccess.getType_identifierRule());
						}
						setWithLastConsumed($current, "integer", lv_integer_2_0, "integer");
					}
				)
			)
			    |
			(
				(
					lv_string_3_0=String
					{
						newLeafNode(lv_string_3_0, grammarAccess.getType_identifierAccess().getStringStringKeyword_1_2_0());
					}
					{
						if ($current==null) {
							$current = createModelElement(grammarAccess.getType_identifierRule());
						}
						setWithLastConsumed($current, "string", lv_string_3_0, "string");
					}
				)
			)
		)
	)
;

// Entry rule entryRuleunsigned_constant
entryRuleunsigned_constant returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getUnsigned_constantRule()); }
	iv_ruleunsigned_constant=ruleunsigned_constant
	{ $current=$iv_ruleunsigned_constant.current; }
	EOF;

// Rule unsigned_constant
ruleunsigned_constant returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getUnsigned_constantAccess().getNumberUnsigned_numberParserRuleCall_0_0());
				}
				lv_number_0_0=ruleunsigned_number
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getUnsigned_constantRule());
					}
					set(
						$current,
						"number",
						lv_number_0_0,
						"org.xtext.compiler.pascal.Pascal.unsigned_number");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				lv_string_1_0=RULE_STRING
				{
					newLeafNode(lv_string_1_0, grammarAccess.getUnsigned_constantAccess().getStringSTRINGTerminalRuleCall_1_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getUnsigned_constantRule());
					}
					setWithLastConsumed(
						$current,
						"string",
						lv_string_1_0,
						"org.xtext.compiler.pascal.Pascal.STRING");
				}
			)
		)
		    |
		(
			(
				lv_nil_2_0=RULE_NIL
				{
					newLeafNode(lv_nil_2_0, grammarAccess.getUnsigned_constantAccess().getNilNILTerminalRuleCall_2_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getUnsigned_constantRule());
					}
					setWithLastConsumed(
						$current,
						"nil",
						lv_nil_2_0,
						"org.xtext.compiler.pascal.Pascal.NIL");
				}
			)
		)
	)
;

// Entry rule entryRuleunsigned_number
entryRuleunsigned_number returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getUnsigned_numberRule()); }
	iv_ruleunsigned_number=ruleunsigned_number
	{ $current=$iv_ruleunsigned_number.current; }
	EOF;

// Rule unsigned_number
ruleunsigned_number returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getUnsigned_numberAccess().getNumbersUnsigned_integerParserRuleCall_0());
			}
			lv_numbers_0_0=ruleunsigned_integer
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getUnsigned_numberRule());
				}
				set(
					$current,
					"numbers",
					lv_numbers_0_0,
					"org.xtext.compiler.pascal.Pascal.unsigned_integer");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRuleprocedure_statement
entryRuleprocedure_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getProcedure_statementRule()); }
	iv_ruleprocedure_statement=ruleprocedure_statement
	{ $current=$iv_ruleprocedure_statement.current; }
	EOF;

// Rule procedure_statement
ruleprocedure_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_name_id_0_0=RULE_ID
				{
					newLeafNode(lv_name_id_0_0, grammarAccess.getProcedure_statementAccess().getName_idIDTerminalRuleCall_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getProcedure_statementRule());
					}
					setWithLastConsumed(
						$current,
						"name_id",
						lv_name_id_0_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		(
			otherlv_1=LeftParenthesis
			{
				newLeafNode(otherlv_1, grammarAccess.getProcedure_statementAccess().getLeftParenthesisKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getProcedure_statementAccess().getParametersParameter_listParserRuleCall_1_1_0());
					}
					lv_parameters_2_0=ruleparameter_list
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getProcedure_statementRule());
						}
						set(
							$current,
							"parameters",
							lv_parameters_2_0,
							"org.xtext.compiler.pascal.Pascal.parameter_list");
						afterParserOrEnumRuleCall();
					}
				)
			)
			otherlv_3=RightParenthesis
			{
				newLeafNode(otherlv_3, grammarAccess.getProcedure_statementAccess().getRightParenthesisKeyword_1_2());
			}
		)?
	)
;

// Entry rule entryRuleparameter_list
entryRuleparameter_list returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getParameter_listRule()); }
	iv_ruleparameter_list=ruleparameter_list
	{ $current=$iv_ruleparameter_list.current; }
	EOF;

// Rule parameter_list
ruleparameter_list returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getParameter_listAccess().getParametersActual_parameterParserRuleCall_0_0());
				}
				lv_parameters_0_0=ruleactual_parameter
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getParameter_listRule());
					}
					add(
						$current,
						"parameters",
						lv_parameters_0_0,
						"org.xtext.compiler.pascal.Pascal.actual_parameter");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_1=Comma
			{
				newLeafNode(otherlv_1, grammarAccess.getParameter_listAccess().getCommaKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getParameter_listAccess().getParametersActual_parameterParserRuleCall_1_1_0());
					}
					lv_parameters_2_0=ruleactual_parameter
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getParameter_listRule());
						}
						add(
							$current,
							"parameters",
							lv_parameters_2_0,
							"org.xtext.compiler.pascal.Pascal.actual_parameter");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
	)
;

// Entry rule entryRuleactual_parameter
entryRuleactual_parameter returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getActual_parameterRule()); }
	iv_ruleactual_parameter=ruleactual_parameter
	{ $current=$iv_ruleactual_parameter.current; }
	EOF;

// Rule actual_parameter
ruleactual_parameter returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getActual_parameterAccess().getContentExpressionParserRuleCall_0());
			}
			lv_content_0_0=ruleexpression
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getActual_parameterRule());
				}
				set(
					$current,
					"content",
					lv_content_0_0,
					"org.xtext.compiler.pascal.Pascal.expression");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRulestructured_statement
entryRulestructured_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getStructured_statementRule()); }
	iv_rulestructured_statement=rulestructured_statement
	{ $current=$iv_rulestructured_statement.current; }
	EOF;

// Rule structured_statement
rulestructured_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getStructured_statementAccess().getCompound_statCompound_statementParserRuleCall_0_0());
				}
				lv_compound_stat_0_0=rulecompound_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getStructured_statementRule());
					}
					set(
						$current,
						"compound_stat",
						lv_compound_stat_0_0,
						"org.xtext.compiler.pascal.Pascal.compound_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getStructured_statementAccess().getConditional_statConditional_statementParserRuleCall_1_0());
				}
				lv_conditional_stat_1_0=ruleconditional_statement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getStructured_statementRule());
					}
					set(
						$current,
						"conditional_stat",
						lv_conditional_stat_1_0,
						"org.xtext.compiler.pascal.Pascal.conditional_statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleconditional_statement
entryRuleconditional_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getConditional_statementRule()); }
	iv_ruleconditional_statement=ruleconditional_statement
	{ $current=$iv_ruleconditional_statement.current; }
	EOF;

// Rule conditional_statement
ruleconditional_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getConditional_statementAccess().getCond_statementsCase_statementParserRuleCall_0());
			}
			lv_cond_statements_0_0=rulecase_statement
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getConditional_statementRule());
				}
				set(
					$current,
					"cond_statements",
					lv_cond_statements_0_0,
					"org.xtext.compiler.pascal.Pascal.case_statement");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRulecase_statement
entryRulecase_statement returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getCase_statementRule()); }
	iv_rulecase_statement=rulecase_statement
	{ $current=$iv_rulecase_statement.current; }
	EOF;

// Rule case_statement
rulecase_statement returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=Case
		{
			newLeafNode(otherlv_0, grammarAccess.getCase_statementAccess().getCaseKeyword_0());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getCase_statementAccess().getExpExpressionParserRuleCall_1_0());
				}
				lv_exp_1_0=ruleexpression
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getCase_statementRule());
					}
					set(
						$current,
						"exp",
						lv_exp_1_0,
						"org.xtext.compiler.pascal.Pascal.expression");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_2=Of
		{
			newLeafNode(otherlv_2, grammarAccess.getCase_statementAccess().getOfKeyword_2());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getCase_statementAccess().getCase_listCase_list_elementParserRuleCall_3_0());
				}
				lv_case_list_3_0=rulecase_list_element
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getCase_statementRule());
					}
					add(
						$current,
						"case_list",
						lv_case_list_3_0,
						"org.xtext.compiler.pascal.Pascal.case_list_element");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_4=Semicolon
			{
				newLeafNode(otherlv_4, grammarAccess.getCase_statementAccess().getSemicolonKeyword_4_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getCase_statementAccess().getCase_listCase_list_elementParserRuleCall_4_1_0());
					}
					lv_case_list_5_0=rulecase_list_element
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getCase_statementRule());
						}
						add(
							$current,
							"case_list",
							lv_case_list_5_0,
							"org.xtext.compiler.pascal.Pascal.case_list_element");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
		(
			otherlv_6=Semicolon
			{
				newLeafNode(otherlv_6, grammarAccess.getCase_statementAccess().getSemicolonKeyword_5());
			}
		)?
		(
			otherlv_7=Else
			{
				newLeafNode(otherlv_7, grammarAccess.getCase_statementAccess().getElseKeyword_6_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getCase_statementAccess().getCase_statementsStatementsParserRuleCall_6_1_0());
					}
					lv_case_statements_8_0=rulestatements
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getCase_statementRule());
						}
						set(
							$current,
							"case_statements",
							lv_case_statements_8_0,
							"org.xtext.compiler.pascal.Pascal.statements");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)?
		otherlv_9=End
		{
			newLeafNode(otherlv_9, grammarAccess.getCase_statementAccess().getEndKeyword_7());
		}
	)
;

// Entry rule entryRulecase_list_element
entryRulecase_list_element returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getCase_list_elementRule()); }
	iv_rulecase_list_element=rulecase_list_element
	{ $current=$iv_rulecase_list_element.current; }
	EOF;

// Rule case_list_element
rulecase_list_element returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getCase_list_elementAccess().getConstsConst_listParserRuleCall_0_0());
				}
				lv_consts_0_0=ruleconst_list
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getCase_list_elementRule());
					}
					set(
						$current,
						"consts",
						lv_consts_0_0,
						"org.xtext.compiler.pascal.Pascal.const_list");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_1=Colon
		{
			newLeafNode(otherlv_1, grammarAccess.getCase_list_elementAccess().getColonKeyword_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getCase_list_elementAccess().getCase_statementStatementParserRuleCall_2_0());
				}
				lv_case_statement_2_0=rulestatement
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getCase_list_elementRule());
					}
					set(
						$current,
						"case_statement",
						lv_case_statement_2_0,
						"org.xtext.compiler.pascal.Pascal.statement");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleconst_list
entryRuleconst_list returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getConst_listRule()); }
	iv_ruleconst_list=ruleconst_list
	{ $current=$iv_ruleconst_list.current; }
	EOF;

// Rule const_list
ruleconst_list returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getConst_listAccess().getConstantsConstantParserRuleCall_0_0());
				}
				lv_constants_0_0=ruleconstant
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getConst_listRule());
					}
					add(
						$current,
						"constants",
						lv_constants_0_0,
						"org.xtext.compiler.pascal.Pascal.constant");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_1=Comma
			{
				newLeafNode(otherlv_1, grammarAccess.getConst_listAccess().getCommaKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getConst_listAccess().getConstantsConstantParserRuleCall_1_1_0());
					}
					lv_constants_2_0=ruleconstant
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getConst_listRule());
						}
						add(
							$current,
							"constants",
							lv_constants_2_0,
							"org.xtext.compiler.pascal.Pascal.constant");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
	)
;

// Entry rule entryRuleunsigned_integer
entryRuleunsigned_integer returns [String current=null]:
	{ newCompositeNode(grammarAccess.getUnsigned_integerRule()); }
	iv_ruleunsigned_integer=ruleunsigned_integer
	{ $current=$iv_ruleunsigned_integer.current.getText(); }
	EOF;

// Rule unsigned_integer
ruleunsigned_integer returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	this_NUM_INT_0=RULE_NUM_INT
	{
		$current.merge(this_NUM_INT_0);
	}
	{
		newLeafNode(this_NUM_INT_0, grammarAccess.getUnsigned_integerAccess().getNUM_INTTerminalRuleCall());
	}
;

// Entry rule entryRuleadditive_operator
entryRuleadditive_operator returns [String current=null]:
	{ newCompositeNode(grammarAccess.getAdditive_operatorRule()); }
	iv_ruleadditive_operator=ruleadditive_operator
	{ $current=$iv_ruleadditive_operator.current.getText(); }
	EOF;

// Rule additive_operator
ruleadditive_operator returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		this_PLUS_0=RULE_PLUS
		{
			$current.merge(this_PLUS_0);
		}
		{
			newLeafNode(this_PLUS_0, grammarAccess.getAdditive_operatorAccess().getPLUSTerminalRuleCall_0());
		}
		    |
		this_MINUS_1=RULE_MINUS
		{
			$current.merge(this_MINUS_1);
		}
		{
			newLeafNode(this_MINUS_1, grammarAccess.getAdditive_operatorAccess().getMINUSTerminalRuleCall_1());
		}
		    |
		this_OR_2=RULE_OR
		{
			$current.merge(this_OR_2);
		}
		{
			newLeafNode(this_OR_2, grammarAccess.getAdditive_operatorAccess().getORTerminalRuleCall_2());
		}
	)
;

// Entry rule entryRulemultiplicative_operator
entryRulemultiplicative_operator returns [String current=null]:
	{ newCompositeNode(grammarAccess.getMultiplicative_operatorRule()); }
	iv_rulemultiplicative_operator=rulemultiplicative_operator
	{ $current=$iv_rulemultiplicative_operator.current.getText(); }
	EOF;

// Rule multiplicative_operator
rulemultiplicative_operator returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		this_STAR_0=RULE_STAR
		{
			$current.merge(this_STAR_0);
		}
		{
			newLeafNode(this_STAR_0, grammarAccess.getMultiplicative_operatorAccess().getSTARTerminalRuleCall_0());
		}
		    |
		this_SLASH_1=RULE_SLASH
		{
			$current.merge(this_SLASH_1);
		}
		{
			newLeafNode(this_SLASH_1, grammarAccess.getMultiplicative_operatorAccess().getSLASHTerminalRuleCall_1());
		}
		    |
		this_DIV_2=RULE_DIV
		{
			$current.merge(this_DIV_2);
		}
		{
			newLeafNode(this_DIV_2, grammarAccess.getMultiplicative_operatorAccess().getDIVTerminalRuleCall_2());
		}
		    |
		this_MOD_3=RULE_MOD
		{
			$current.merge(this_MOD_3);
		}
		{
			newLeafNode(this_MOD_3, grammarAccess.getMultiplicative_operatorAccess().getMODTerminalRuleCall_3());
		}
		    |
		this_AND_4=RULE_AND
		{
			$current.merge(this_AND_4);
		}
		{
			newLeafNode(this_AND_4, grammarAccess.getMultiplicative_operatorAccess().getANDTerminalRuleCall_4());
		}
	)
;

// Entry rule entryRuleprocedure_and_function_declaration_part
entryRuleprocedure_and_function_declaration_part returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getProcedure_and_function_declaration_partRule()); }
	iv_ruleprocedure_and_function_declaration_part=ruleprocedure_and_function_declaration_part
	{ $current=$iv_ruleprocedure_and_function_declaration_part.current; }
	EOF;

// Rule procedure_and_function_declaration_part
ruleprocedure_and_function_declaration_part returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getProcedure_and_function_declaration_partAccess().getSubroutineProcedure_or_function_declarationParserRuleCall_0_0());
				}
				lv_subroutine_0_0=ruleprocedure_or_function_declaration
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getProcedure_and_function_declaration_partRule());
					}
					set(
						$current,
						"subroutine",
						lv_subroutine_0_0,
						"org.xtext.compiler.pascal.Pascal.procedure_or_function_declaration");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_1=Semicolon
		{
			newLeafNode(otherlv_1, grammarAccess.getProcedure_and_function_declaration_partAccess().getSemicolonKeyword_1());
		}
	)
;

// Entry rule entryRuleprocedure_or_function_declaration
entryRuleprocedure_or_function_declaration returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getProcedure_or_function_declarationRule()); }
	iv_ruleprocedure_or_function_declaration=ruleprocedure_or_function_declaration
	{ $current=$iv_ruleprocedure_or_function_declaration.current; }
	EOF;

// Rule procedure_or_function_declaration
ruleprocedure_or_function_declaration returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getProcedure_or_function_declarationAccess().getProcProcedure_declarationParserRuleCall_0_0());
				}
				lv_proc_0_0=ruleprocedure_declaration
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getProcedure_or_function_declarationRule());
					}
					set(
						$current,
						"proc",
						lv_proc_0_0,
						"org.xtext.compiler.pascal.Pascal.procedure_declaration");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getProcedure_or_function_declarationAccess().getFuncFunction_declarationParserRuleCall_1_0());
				}
				lv_func_1_0=rulefunction_declaration
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getProcedure_or_function_declarationRule());
					}
					set(
						$current,
						"func",
						lv_func_1_0,
						"org.xtext.compiler.pascal.Pascal.function_declaration");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleprocedure_declaration
entryRuleprocedure_declaration returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getProcedure_declarationRule()); }
	iv_ruleprocedure_declaration=ruleprocedure_declaration
	{ $current=$iv_ruleprocedure_declaration.current; }
	EOF;

// Rule procedure_declaration
ruleprocedure_declaration returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		{
			newCompositeNode(grammarAccess.getProcedure_declarationAccess().getProcedureParserRuleCall_0());
		}
		ruleprocedure
		{
			afterParserOrEnumRuleCall();
		}
		(
			(
				lv_names_1_0=RULE_ID
				{
					newLeafNode(lv_names_1_0, grammarAccess.getProcedure_declarationAccess().getNamesIDTerminalRuleCall_1_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getProcedure_declarationRule());
					}
					setWithLastConsumed(
						$current,
						"names",
						lv_names_1_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getProcedure_declarationAccess().getParametersFormal_parameter_listParserRuleCall_2_0());
				}
				lv_parameters_2_0=ruleformal_parameter_list
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getProcedure_declarationRule());
					}
					set(
						$current,
						"parameters",
						lv_parameters_2_0,
						"org.xtext.compiler.pascal.Pascal.formal_parameter_list");
					afterParserOrEnumRuleCall();
				}
			)
		)?
		otherlv_3=Semicolon
		{
			newLeafNode(otherlv_3, grammarAccess.getProcedure_declarationAccess().getSemicolonKeyword_3());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getProcedure_declarationAccess().getBlockBlockParserRuleCall_4_0());
				}
				lv_block_4_0=ruleblock
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getProcedure_declarationRule());
					}
					set(
						$current,
						"block",
						lv_block_4_0,
						"org.xtext.compiler.pascal.Pascal.block");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulefunction_declaration
entryRulefunction_declaration returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getFunction_declarationRule()); }
	iv_rulefunction_declaration=rulefunction_declaration
	{ $current=$iv_rulefunction_declaration.current; }
	EOF;

// Rule function_declaration
rulefunction_declaration returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		{
			newCompositeNode(grammarAccess.getFunction_declarationAccess().getFunctionParserRuleCall_0());
		}
		rulefunction
		{
			afterParserOrEnumRuleCall();
		}
		(
			(
				lv_names_1_0=RULE_ID
				{
					newLeafNode(lv_names_1_0, grammarAccess.getFunction_declarationAccess().getNamesIDTerminalRuleCall_1_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getFunction_declarationRule());
					}
					setWithLastConsumed(
						$current,
						"names",
						lv_names_1_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getFunction_declarationAccess().getParametersFormal_parameter_listParserRuleCall_2_0());
				}
				lv_parameters_2_0=ruleformal_parameter_list
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFunction_declarationRule());
					}
					set(
						$current,
						"parameters",
						lv_parameters_2_0,
						"org.xtext.compiler.pascal.Pascal.formal_parameter_list");
					afterParserOrEnumRuleCall();
				}
			)
		)?
		otherlv_3=Colon
		{
			newLeafNode(otherlv_3, grammarAccess.getFunction_declarationAccess().getColonKeyword_3());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getFunction_declarationAccess().getTypesResult_typeParserRuleCall_4_0());
				}
				lv_types_4_0=ruleresult_type
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFunction_declarationRule());
					}
					set(
						$current,
						"types",
						lv_types_4_0,
						"org.xtext.compiler.pascal.Pascal.result_type");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_5=Semicolon
		{
			newLeafNode(otherlv_5, grammarAccess.getFunction_declarationAccess().getSemicolonKeyword_5());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getFunction_declarationAccess().getBlockBlockParserRuleCall_6_0());
				}
				lv_block_6_0=ruleblock
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFunction_declarationRule());
					}
					set(
						$current,
						"block",
						lv_block_6_0,
						"org.xtext.compiler.pascal.Pascal.block");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRulefunction_designator
entryRulefunction_designator returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getFunction_designatorRule()); }
	iv_rulefunction_designator=rulefunction_designator
	{ $current=$iv_rulefunction_designator.current; }
	EOF;

// Rule function_designator
rulefunction_designator returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_name_function_0_0=RULE_ID
				{
					newLeafNode(lv_name_function_0_0, grammarAccess.getFunction_designatorAccess().getName_functionIDTerminalRuleCall_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getFunction_designatorRule());
					}
					setWithLastConsumed(
						$current,
						"name_function",
						lv_name_function_0_0,
						"org.xtext.compiler.pascal.Pascal.ID");
				}
			)
		)
		otherlv_1=LeftParenthesis
		{
			newLeafNode(otherlv_1, grammarAccess.getFunction_designatorAccess().getLeftParenthesisKeyword_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getFunction_designatorAccess().getParametersParameter_listParserRuleCall_2_0());
				}
				lv_parameters_2_0=ruleparameter_list
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFunction_designatorRule());
					}
					set(
						$current,
						"parameters",
						lv_parameters_2_0,
						"org.xtext.compiler.pascal.Pascal.parameter_list");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_3=RightParenthesis
		{
			newLeafNode(otherlv_3, grammarAccess.getFunction_designatorAccess().getRightParenthesisKeyword_3());
		}
	)
;

// Entry rule entryRuleformal_parameter_list
entryRuleformal_parameter_list returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getFormal_parameter_listRule()); }
	iv_ruleformal_parameter_list=ruleformal_parameter_list
	{ $current=$iv_ruleformal_parameter_list.current; }
	EOF;

// Rule formal_parameter_list
ruleformal_parameter_list returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0=LeftParenthesis
		{
			newLeafNode(otherlv_0, grammarAccess.getFormal_parameter_listAccess().getLeftParenthesisKeyword_0());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getFormal_parameter_listAccess().getParametersFormal_parameter_sectionParserRuleCall_1_0());
				}
				lv_parameters_1_0=ruleformal_parameter_section
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFormal_parameter_listRule());
					}
					add(
						$current,
						"parameters",
						lv_parameters_1_0,
						"org.xtext.compiler.pascal.Pascal.formal_parameter_section");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			otherlv_2=Semicolon
			{
				newLeafNode(otherlv_2, grammarAccess.getFormal_parameter_listAccess().getSemicolonKeyword_2_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getFormal_parameter_listAccess().getParametersFormal_parameter_sectionParserRuleCall_2_1_0());
					}
					lv_parameters_3_0=ruleformal_parameter_section
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFormal_parameter_listRule());
						}
						add(
							$current,
							"parameters",
							lv_parameters_3_0,
							"org.xtext.compiler.pascal.Pascal.formal_parameter_section");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)*
		otherlv_4=RightParenthesis
		{
			newLeafNode(otherlv_4, grammarAccess.getFormal_parameter_listAccess().getRightParenthesisKeyword_3());
		}
	)
;

// Entry rule entryRuleformal_parameter_section
entryRuleformal_parameter_section returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getFormal_parameter_sectionRule()); }
	iv_ruleformal_parameter_section=ruleformal_parameter_section
	{ $current=$iv_ruleformal_parameter_section.current; }
	EOF;

// Rule formal_parameter_section
ruleformal_parameter_section returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getFormal_parameter_sectionAccess().getParametersParameter_groupParserRuleCall_0_0());
				}
				lv_parameters_0_0=ruleparameter_group
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFormal_parameter_sectionRule());
					}
					add(
						$current,
						"parameters",
						lv_parameters_0_0,
						"org.xtext.compiler.pascal.Pascal.parameter_group");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			otherlv_1=Var
			{
				newLeafNode(otherlv_1, grammarAccess.getFormal_parameter_sectionAccess().getVarKeyword_1_0());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getFormal_parameter_sectionAccess().getParametersParameter_groupParserRuleCall_1_1_0());
					}
					lv_parameters_2_0=ruleparameter_group
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFormal_parameter_sectionRule());
						}
						add(
							$current,
							"parameters",
							lv_parameters_2_0,
							"org.xtext.compiler.pascal.Pascal.parameter_group");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)
		    |
		(
			{
				newCompositeNode(grammarAccess.getFormal_parameter_sectionAccess().getFunctionParserRuleCall_2_0());
			}
			rulefunction
			{
				afterParserOrEnumRuleCall();
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getFormal_parameter_sectionAccess().getParametersParameter_groupParserRuleCall_2_1_0());
					}
					lv_parameters_4_0=ruleparameter_group
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFormal_parameter_sectionRule());
						}
						add(
							$current,
							"parameters",
							lv_parameters_4_0,
							"org.xtext.compiler.pascal.Pascal.parameter_group");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)
		    |
		(
			{
				newCompositeNode(grammarAccess.getFormal_parameter_sectionAccess().getProcedureParserRuleCall_3_0());
			}
			ruleprocedure
			{
				afterParserOrEnumRuleCall();
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getFormal_parameter_sectionAccess().getParametersParameter_groupParserRuleCall_3_1_0());
					}
					lv_parameters_6_0=ruleparameter_group
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFormal_parameter_sectionRule());
						}
						add(
							$current,
							"parameters",
							lv_parameters_6_0,
							"org.xtext.compiler.pascal.Pascal.parameter_group");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)
	)
;

// Entry rule entryRuleparameter_group
entryRuleparameter_group returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getParameter_groupRule()); }
	iv_ruleparameter_group=ruleparameter_group
	{ $current=$iv_ruleparameter_group.current; }
	EOF;

// Rule parameter_group
ruleparameter_group returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getParameter_groupAccess().getNamesIdentifier_listParserRuleCall_0_0());
				}
				lv_names_0_0=ruleidentifier_list
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getParameter_groupRule());
					}
					set(
						$current,
						"names",
						lv_names_0_0,
						"org.xtext.compiler.pascal.Pascal.identifier_list");
					afterParserOrEnumRuleCall();
				}
			)
		)
		otherlv_1=Colon
		{
			newLeafNode(otherlv_1, grammarAccess.getParameter_groupAccess().getColonKeyword_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getParameter_groupAccess().getTypesType_identifierParserRuleCall_2_0());
				}
				lv_types_2_0=ruletype_identifier
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getParameter_groupRule());
					}
					set(
						$current,
						"types",
						lv_types_2_0,
						"org.xtext.compiler.pascal.Pascal.type_identifier");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleresult_type
entryRuleresult_type returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getResult_typeRule()); }
	iv_ruleresult_type=ruleresult_type
	{ $current=$iv_ruleresult_type.current; }
	EOF;

// Rule result_type
ruleresult_type returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	{
		newCompositeNode(grammarAccess.getResult_typeAccess().getType_identifierParserRuleCall());
	}
	this_type_identifier_0=ruletype_identifier
	{
		$current = $this_type_identifier_0.current;
		afterParserOrEnumRuleCall();
	}
;

// Entry rule entryRulebool
entryRulebool returns [String current=null]:
	{ newCompositeNode(grammarAccess.getBoolRule()); }
	iv_rulebool=rulebool
	{ $current=$iv_rulebool.current.getText(); }
	EOF;

// Rule bool
rulebool returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		kw=True
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getBoolAccess().getTrueKeyword_0());
		}
		    |
		kw=False
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getBoolAccess().getFalseKeyword_1());
		}
	)
;

// Entry rule entryRuleprocedure
entryRuleprocedure returns [String current=null]:
	{ newCompositeNode(grammarAccess.getProcedureRule()); }
	iv_ruleprocedure=ruleprocedure
	{ $current=$iv_ruleprocedure.current.getText(); }
	EOF;

// Rule procedure
ruleprocedure returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw=Procedure
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getProcedureAccess().getProcedureKeyword());
	}
;

// Entry rule entryRulefunction
entryRulefunction returns [String current=null]:
	{ newCompositeNode(grammarAccess.getFunctionRule()); }
	iv_rulefunction=rulefunction
	{ $current=$iv_rulefunction.current.getText(); }
	EOF;

// Rule function
rulefunction returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw=Function
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getFunctionAccess().getFunctionKeyword());
	}
;

// Entry rule entryRulesign
entryRulesign returns [String current=null]:
	{ newCompositeNode(grammarAccess.getSignRule()); }
	iv_rulesign=rulesign
	{ $current=$iv_rulesign.current.getText(); }
	EOF;

// Rule sign
rulesign returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		this_PLUS_0=RULE_PLUS
		{
			$current.merge(this_PLUS_0);
		}
		{
			newLeafNode(this_PLUS_0, grammarAccess.getSignAccess().getPLUSTerminalRuleCall_0());
		}
		    |
		this_MINUS_1=RULE_MINUS
		{
			$current.merge(this_MINUS_1);
		}
		{
			newLeafNode(this_MINUS_1, grammarAccess.getSignAccess().getMINUSTerminalRuleCall_1());
		}
	)
;
