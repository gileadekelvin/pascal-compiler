/*
 * generated by Xtext 2.14.0.RC1
 */
package org.xtext.compiler.pascal.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.compiler.pascal.pascal.PascalPackage;
import org.xtext.compiler.pascal.pascal.assignment_statement;
import org.xtext.compiler.pascal.pascal.block;
import org.xtext.compiler.pascal.pascal.compound_statement;
import org.xtext.compiler.pascal.pascal.constant;
import org.xtext.compiler.pascal.pascal.constant_chr;
import org.xtext.compiler.pascal.pascal.constant_definition;
import org.xtext.compiler.pascal.pascal.constant_definition_part;
import org.xtext.compiler.pascal.pascal.element;
import org.xtext.compiler.pascal.pascal.elementList;
import org.xtext.compiler.pascal.pascal.expression;
import org.xtext.compiler.pascal.pascal.factor;
import org.xtext.compiler.pascal.pascal.identifier_list;
import org.xtext.compiler.pascal.pascal.label;
import org.xtext.compiler.pascal.pascal.pascal;
import org.xtext.compiler.pascal.pascal.program;
import org.xtext.compiler.pascal.pascal.program_heading_block;
import org.xtext.compiler.pascal.pascal.set;
import org.xtext.compiler.pascal.pascal.signed_factor;
import org.xtext.compiler.pascal.pascal.simple_expression;
import org.xtext.compiler.pascal.pascal.simple_statement;
import org.xtext.compiler.pascal.pascal.simple_type;
import org.xtext.compiler.pascal.pascal.statement;
import org.xtext.compiler.pascal.pascal.statements;
import org.xtext.compiler.pascal.pascal.string_type;
import org.xtext.compiler.pascal.pascal.subrange_type;
import org.xtext.compiler.pascal.pascal.term;
import org.xtext.compiler.pascal.pascal.type;
import org.xtext.compiler.pascal.pascal.type_identifier;
import org.xtext.compiler.pascal.pascal.unlabelled_statement;
import org.xtext.compiler.pascal.pascal.unsigned_constant;
import org.xtext.compiler.pascal.pascal.unsigned_number;
import org.xtext.compiler.pascal.pascal.variable;
import org.xtext.compiler.pascal.pascal.variable_declaration_part;
import org.xtext.compiler.pascal.services.PascalGrammarAccess;

@SuppressWarnings("all")
public class PascalSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PascalGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PascalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PascalPackage.ASSIGNMENT_STATEMENT:
				sequence_assignment_statement(context, (assignment_statement) semanticObject); 
				return; 
			case PascalPackage.BLOCK:
				sequence_block(context, (block) semanticObject); 
				return; 
			case PascalPackage.COMPOUND_STATEMENT:
				sequence_compound_statement(context, (compound_statement) semanticObject); 
				return; 
			case PascalPackage.CONSTANT:
				sequence_constant(context, (constant) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_CHR:
				sequence_constant_chr(context, (constant_chr) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION:
				sequence_constant_constant_chr_constant_definition_unsigned_number(context, (constant_definition) semanticObject); 
				return; 
			case PascalPackage.CONSTANT_DEFINITION_PART:
				sequence_constant_definition_part(context, (constant_definition_part) semanticObject); 
				return; 
			case PascalPackage.ELEMENT:
				sequence_element(context, (element) semanticObject); 
				return; 
			case PascalPackage.ELEMENT_LIST:
				sequence_elementList(context, (elementList) semanticObject); 
				return; 
			case PascalPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case PascalPackage.FACTOR:
				sequence_factor(context, (factor) semanticObject); 
				return; 
			case PascalPackage.IDENTIFIER_LIST:
				if (rule == grammarAccess.getIdentifier_listRule()
						|| rule == grammarAccess.getScalar_typeRule()) {
					sequence_identifier_list(context, (identifier_list) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariable_declarationRule()) {
					sequence_identifier_list_variable_declaration(context, (identifier_list) semanticObject); 
					return; 
				}
				else break;
			case PascalPackage.LABEL:
				sequence_label(context, (label) semanticObject); 
				return; 
			case PascalPackage.PASCAL:
				sequence_pascal(context, (pascal) semanticObject); 
				return; 
			case PascalPackage.PROGRAM:
				sequence_program(context, (program) semanticObject); 
				return; 
			case PascalPackage.PROGRAM_HEADING_BLOCK:
				sequence_program_heading_block(context, (program_heading_block) semanticObject); 
				return; 
			case PascalPackage.SET:
				sequence_set(context, (set) semanticObject); 
				return; 
			case PascalPackage.SIGNED_FACTOR:
				sequence_signed_factor(context, (signed_factor) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_EXPRESSION:
				sequence_simple_expression(context, (simple_expression) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_STATEMENT:
				sequence_simple_statement(context, (simple_statement) semanticObject); 
				return; 
			case PascalPackage.SIMPLE_TYPE:
				sequence_simple_type(context, (simple_type) semanticObject); 
				return; 
			case PascalPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case PascalPackage.STATEMENTS:
				sequence_statements(context, (statements) semanticObject); 
				return; 
			case PascalPackage.STRING_TYPE:
				sequence_string_type(context, (string_type) semanticObject); 
				return; 
			case PascalPackage.SUBRANGE_TYPE:
				sequence_subrange_type(context, (subrange_type) semanticObject); 
				return; 
			case PascalPackage.TERM:
				sequence_term(context, (term) semanticObject); 
				return; 
			case PascalPackage.TYPE:
				sequence_type(context, (type) semanticObject); 
				return; 
			case PascalPackage.TYPE_IDENTIFIER:
				sequence_type_identifier(context, (type_identifier) semanticObject); 
				return; 
			case PascalPackage.UNLABELLED_STATEMENT:
				sequence_unlabelled_statement(context, (unlabelled_statement) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_CONSTANT:
				sequence_unsigned_constant(context, (unsigned_constant) semanticObject); 
				return; 
			case PascalPackage.UNSIGNED_NUMBER:
				sequence_unsigned_number(context, (unsigned_number) semanticObject); 
				return; 
			case PascalPackage.VARIABLE:
				sequence_variable(context, (variable) semanticObject); 
				return; 
			case PascalPackage.VARIABLE_DECLARATION_PART:
				sequence_variable_declaration_part(context, (variable_declaration_part) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     assignment_statement returns assignment_statement
	 *
	 * Constraint:
	 *     (variable=variable expression=expression)
	 */
	protected void sequence_assignment_statement(ISerializationContext context, assignment_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignment_statementAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignment_statementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block returns block
	 *
	 * Constraint:
	 *     ((constantpart+=constant_definition_part | variablepart+=variable_declaration_part)* statement=compound_statement)
	 */
	protected void sequence_block(ISerializationContext context, block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     compound_statement returns compound_statement
	 *
	 * Constraint:
	 *     sequence=statements
	 */
	protected void sequence_compound_statement(ISerializationContext context, compound_statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.COMPOUND_STATEMENT__SEQUENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.COMPOUND_STATEMENT__SEQUENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompound_statementAccess().getSequenceStatementsParserRuleCall_1_0(), semanticObject.getSequence());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant_chr
	 *     constant_chr returns constant_chr
	 *
	 * Constraint:
	 *     numbers+=unsigned_integer
	 */
	protected void sequence_constant_chr(ISerializationContext context, constant_chr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant returns constant
	 *
	 * Constraint:
	 *     (names+=ID | names+=ID | string+=STRING)
	 */
	protected void sequence_constant(ISerializationContext context, constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant_definition returns constant_definition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             names+=ID | 
	 *             names+=ID | 
	 *             string+=STRING | 
	 *             numbers+=unsigned_integer | 
	 *             numbers+=unsigned_real | 
	 *             numbers+=unsigned_integer
	 *         )
	 *     )
	 */
	protected void sequence_constant_constant_chr_constant_definition_unsigned_number(ISerializationContext context, constant_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant_definition_part returns constant_definition_part
	 *
	 * Constraint:
	 *     constants+=constant_definition+
	 */
	protected void sequence_constant_definition_part(ISerializationContext context, constant_definition_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     elementList returns elementList
	 *
	 * Constraint:
	 *     (elements+=element elements+=element*)
	 */
	protected void sequence_elementList(ISerializationContext context, elementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     element returns element
	 *
	 * Constraint:
	 *     (expressions+=expression (dotdot+=DOTDOT expressions+=expression)?)
	 */
	protected void sequence_element(ISerializationContext context, element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (expressions+=simple_expression (operators+=relational_operator expressions+=expression)?)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     factor returns factor
	 *
	 * Constraint:
	 *     (
	 *         variable=variable | 
	 *         expression=expression | 
	 *         constant=unsigned_constant | 
	 *         set=set | 
	 *         factor=factor | 
	 *         boolean+=bool
	 *     )
	 */
	protected void sequence_factor(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     identifier_list returns identifier_list
	 *     scalar_type returns identifier_list
	 *
	 * Constraint:
	 *     (names+=ID names+=ID*)
	 */
	protected void sequence_identifier_list(ISerializationContext context, identifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variable_declaration returns identifier_list
	 *
	 * Constraint:
	 *     (names+=ID names+=ID* types+=type)
	 */
	protected void sequence_identifier_list_variable_declaration(ISerializationContext context, identifier_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     label returns label
	 *
	 * Constraint:
	 *     number=unsigned_integer
	 */
	protected void sequence_label(ISerializationContext context, label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.LABEL__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.LABEL__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getNumberUnsigned_integerParserRuleCall_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     pascal returns pascal
	 *
	 * Constraint:
	 *     program+=program
	 */
	protected void sequence_pascal(ISerializationContext context, pascal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     program_heading_block returns program_heading_block
	 *
	 * Constraint:
	 *     (name=ID identifiers=identifier_list?)
	 */
	protected void sequence_program_heading_block(ISerializationContext context, program_heading_block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     program returns program
	 *
	 * Constraint:
	 *     (heading=program_heading_block block=block)
	 */
	protected void sequence_program(ISerializationContext context, program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROGRAM__HEADING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROGRAM__HEADING));
			if (transientValues.isValueTransient(semanticObject, PascalPackage.Literals.PROGRAM__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PascalPackage.Literals.PROGRAM__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getHeadingProgram_heading_blockParserRuleCall_0_0(), semanticObject.getHeading());
		feeder.accept(grammarAccess.getProgramAccess().getBlockBlockParserRuleCall_1_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     set returns set
	 *
	 * Constraint:
	 *     (elements+=elementList | elements+=elementList)
	 */
	protected void sequence_set(ISerializationContext context, set semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     signed_factor returns signed_factor
	 *
	 * Constraint:
	 *     ((operators+=PLUS | operators+=MINUS)? factors+=factor)
	 */
	protected void sequence_signed_factor(ISerializationContext context, signed_factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simple_expression returns simple_expression
	 *
	 * Constraint:
	 *     (terms+=term (operators+=additive_operator expression+=simple_expression)?)
	 */
	protected void sequence_simple_expression(ISerializationContext context, simple_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simple_statement returns simple_statement
	 *
	 * Constraint:
	 *     (assignment=assignment_statement | procedure=procedure_statement | goto=goto_statement)
	 */
	protected void sequence_simple_statement(ISerializationContext context, simple_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simple_type returns simple_type
	 *
	 * Constraint:
	 *     (types+=scalar_type | types+=subrange_type | types+=type_identifier | types+=string_type)
	 */
	protected void sequence_simple_type(ISerializationContext context, simple_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     ((label=label statement+=unlabelled_statement) | statement+=unlabelled_statement)?
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statements returns statements
	 *
	 * Constraint:
	 *     (statements+=statement statements+=statement*)
	 */
	protected void sequence_statements(ISerializationContext context, statements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     string_type returns string_type
	 *
	 * Constraint:
	 *     (names+=ID | number+=unsigned_number)
	 */
	protected void sequence_string_type(ISerializationContext context, string_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     subrange_type returns subrange_type
	 *
	 * Constraint:
	 *     (constants+=constant constants+=constant)
	 */
	protected void sequence_subrange_type(ISerializationContext context, subrange_type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     term returns term
	 *
	 * Constraint:
	 *     (factors+=signed_factor (operators+=multiplicative_operator terms+=term)?)
	 */
	protected void sequence_term(ISerializationContext context, term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type_identifier returns type_identifier
	 *
	 * Constraint:
	 *     (
	 *         names+=ID | 
	 *         type+='CHAR' | 
	 *         type+='boolean' | 
	 *         type+='integer' | 
	 *         type+='real' | 
	 *         type+='string'
	 *     )
	 */
	protected void sequence_type_identifier(ISerializationContext context, type_identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns type
	 *
	 * Constraint:
	 *     type+=simple_type
	 */
	protected void sequence_type(ISerializationContext context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelled_statement returns unlabelled_statement
	 *
	 * Constraint:
	 *     (simple=simple_statement | structured=structured_statement)
	 */
	protected void sequence_unlabelled_statement(ISerializationContext context, unlabelled_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unsigned_constant returns unsigned_constant
	 *
	 * Constraint:
	 *     (number+=unsigned_number | char+=constant_chr | string+=STRING | nil+=NIL)
	 */
	protected void sequence_unsigned_constant(ISerializationContext context, unsigned_constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constant returns unsigned_number
	 *     unsigned_number returns unsigned_number
	 *
	 * Constraint:
	 *     (numbers+=unsigned_integer | numbers+=unsigned_real)
	 */
	protected void sequence_unsigned_number(ISerializationContext context, unsigned_number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variable_declaration_part returns variable_declaration_part
	 *
	 * Constraint:
	 *     (variable+=variable_declaration variable+=variable_declaration*)
	 */
	protected void sequence_variable_declaration_part(ISerializationContext context, variable_declaration_part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variable returns variable
	 *
	 * Constraint:
	 *     ((names+=ID | names+=ID) (names+=ID? (expression+=expression expression+=expression*)? (expression+=expression expression+=expression*)?)+)
	 */
	protected void sequence_variable(ISerializationContext context, variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
