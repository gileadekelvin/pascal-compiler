/*
 * generated by Xtext 2.14.0.RC1
 */
package org.xtext.compiler.pascal.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class PascalGrammarAccess extends AbstractGrammarElementFinder {
	
	public class PascalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.pascal");
		private final Assignment cProgramAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cProgramProgramParserRuleCall_0 = (RuleCall)cProgramAssignment.eContents().get(0);
		
		//pascal:
		//	program+=program;
		@Override public ParserRule getRule() { return rule; }
		
		//program+=program
		public Assignment getProgramAssignment() { return cProgramAssignment; }
		
		//program
		public RuleCall getProgramProgramParserRuleCall_0() { return cProgramProgramParserRuleCall_0; }
	}
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadingAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadingProgram_heading_blockParserRuleCall_0_0 = (RuleCall)cHeadingAssignment_0.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//program:
		//	heading=program_heading_block block=block ".";
		@Override public ParserRule getRule() { return rule; }
		
		//heading=program_heading_block block=block "."
		public Group getGroup() { return cGroup; }
		
		//heading=program_heading_block
		public Assignment getHeadingAssignment_0() { return cHeadingAssignment_0; }
		
		//program_heading_block
		public RuleCall getHeadingProgram_heading_blockParserRuleCall_0_0() { return cHeadingProgram_heading_blockParserRuleCall_0_0; }
		
		//block=block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }
		
		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}
	public class Program_heading_blockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.program_heading_block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProgramKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIdentifiersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIdentifiersIdentifier_listParserRuleCall_2_1_0 = (RuleCall)cIdentifiersAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//program_heading_block:
		//	"program" name=ID ("(" identifiers=identifier_list ")")? ";";
		@Override public ParserRule getRule() { return rule; }
		
		//"program" name=ID ("(" identifiers=identifier_list ")")? ";"
		public Group getGroup() { return cGroup; }
		
		//"program"
		public Keyword getProgramKeyword_0() { return cProgramKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//("(" identifiers=identifier_list ")")?
		public Group getGroup_2() { return cGroup_2; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//identifiers=identifier_list
		public Assignment getIdentifiersAssignment_2_1() { return cIdentifiersAssignment_2_1; }
		
		//identifier_list
		public RuleCall getIdentifiersIdentifier_listParserRuleCall_2_1_0() { return cIdentifiersIdentifier_listParserRuleCall_2_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class Identifier_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.identifier_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_1_0 = (RuleCall)cNamesAssignment_1_1.eContents().get(0);
		
		//identifier_list:
		//	names+=ID ("," names+=ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//names+=ID ("," names+=ID)*
		public Group getGroup() { return cGroup; }
		
		//names+=ID
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0() { return cNamesIDTerminalRuleCall_0_0; }
		
		//("," names+=ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_1_1() { return cNamesAssignment_1_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_1_0() { return cNamesIDTerminalRuleCall_1_1_0; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cConstantpartAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cConstantpartConstant_definition_partParserRuleCall_0_0_0 = (RuleCall)cConstantpartAssignment_0_0.eContents().get(0);
		private final Assignment cVariablepartAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cVariablepartVariable_declaration_partParserRuleCall_0_1_0 = (RuleCall)cVariablepartAssignment_0_1.eContents().get(0);
		private final Assignment cProcedure_function_partAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final RuleCall cProcedure_function_partProcedure_and_function_declaration_partParserRuleCall_0_2_0 = (RuleCall)cProcedure_function_partAssignment_0_2.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementCompound_statementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		
		//block:
		//	(constantpart+=constant_definition_part | variablepart+=variable_declaration_part |
		//	procedure_function_part+=procedure_and_function_declaration_part)* statement=compound_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//(constantpart+=constant_definition_part | variablepart+=variable_declaration_part |
		//procedure_function_part+=procedure_and_function_declaration_part)* statement=compound_statement
		public Group getGroup() { return cGroup; }
		
		//(constantpart+=constant_definition_part | variablepart+=variable_declaration_part |
		//procedure_function_part+=procedure_and_function_declaration_part)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//constantpart+=constant_definition_part
		public Assignment getConstantpartAssignment_0_0() { return cConstantpartAssignment_0_0; }
		
		//constant_definition_part
		public RuleCall getConstantpartConstant_definition_partParserRuleCall_0_0_0() { return cConstantpartConstant_definition_partParserRuleCall_0_0_0; }
		
		//variablepart+=variable_declaration_part
		public Assignment getVariablepartAssignment_0_1() { return cVariablepartAssignment_0_1; }
		
		//variable_declaration_part
		public RuleCall getVariablepartVariable_declaration_partParserRuleCall_0_1_0() { return cVariablepartVariable_declaration_partParserRuleCall_0_1_0; }
		
		//procedure_function_part+=procedure_and_function_declaration_part
		public Assignment getProcedure_function_partAssignment_0_2() { return cProcedure_function_partAssignment_0_2; }
		
		//procedure_and_function_declaration_part
		public RuleCall getProcedure_function_partProcedure_and_function_declaration_partParserRuleCall_0_2_0() { return cProcedure_function_partProcedure_and_function_declaration_partParserRuleCall_0_2_0; }
		
		//statement=compound_statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }
		
		//compound_statement
		public RuleCall getStatementCompound_statementParserRuleCall_1_0() { return cStatementCompound_statementParserRuleCall_1_0; }
	}
	public class Constant_definition_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.constant_definition_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cConstantsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cConstantsConstant_definitionParserRuleCall_1_0_0 = (RuleCall)cConstantsAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//constant_definition_part:
		//	'const' (constants+=constant_definition ';')+;
		@Override public ParserRule getRule() { return rule; }
		
		//'const' (constants+=constant_definition ';')+
		public Group getGroup() { return cGroup; }
		
		//'const'
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }
		
		//(constants+=constant_definition ';')+
		public Group getGroup_1() { return cGroup_1; }
		
		//constants+=constant_definition
		public Assignment getConstantsAssignment_1_0() { return cConstantsAssignment_1_0; }
		
		//constant_definition
		public RuleCall getConstantsConstant_definitionParserRuleCall_1_0_0() { return cConstantsConstant_definitionParserRuleCall_1_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}
	public class Constant_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.constant_definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cEQUALTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//constant_definition:
		//	name=ID EQUAL constant;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID EQUAL constant
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//EQUAL
		public RuleCall getEQUALTerminalRuleCall_1() { return cEQUALTerminalRuleCall_1; }
		
		//constant
		public RuleCall getConstantParserRuleCall_2() { return cConstantParserRuleCall_2; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnsigned_numberParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cSignParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cUnsigned_numberParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cNamesAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cNamesIDTerminalRuleCall_2_0 = (RuleCall)cNamesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cSignParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cNamesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_3_1_0 = (RuleCall)cNamesAssignment_3_1.eContents().get(0);
		private final Assignment cStringAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cStringSTRINGTerminalRuleCall_4_0 = (RuleCall)cStringAssignment_4.eContents().get(0);
		private final RuleCall cConstant_chrParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//constant:
		//	unsigned_number
		//	| sign unsigned_number
		//	| names+=ID
		//	| sign names+=ID
		//	| string+=STRING
		//	| constant_chr;
		@Override public ParserRule getRule() { return rule; }
		
		//unsigned_number | sign unsigned_number | names+=ID | sign names+=ID | string+=STRING | constant_chr
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//unsigned_number
		public RuleCall getUnsigned_numberParserRuleCall_0() { return cUnsigned_numberParserRuleCall_0; }
		
		//sign unsigned_number
		public Group getGroup_1() { return cGroup_1; }
		
		//sign
		public RuleCall getSignParserRuleCall_1_0() { return cSignParserRuleCall_1_0; }
		
		//unsigned_number
		public RuleCall getUnsigned_numberParserRuleCall_1_1() { return cUnsigned_numberParserRuleCall_1_1; }
		
		//names+=ID
		public Assignment getNamesAssignment_2() { return cNamesAssignment_2; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_2_0() { return cNamesIDTerminalRuleCall_2_0; }
		
		//sign names+=ID
		public Group getGroup_3() { return cGroup_3; }
		
		//sign
		public RuleCall getSignParserRuleCall_3_0() { return cSignParserRuleCall_3_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_3_1() { return cNamesAssignment_3_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_3_1_0() { return cNamesIDTerminalRuleCall_3_1_0; }
		
		//string+=STRING
		public Assignment getStringAssignment_4() { return cStringAssignment_4; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_4_0() { return cStringSTRINGTerminalRuleCall_4_0; }
		
		//constant_chr
		public RuleCall getConstant_chrParserRuleCall_5() { return cConstant_chrParserRuleCall_5; }
	}
	public class Variable_declaration_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.variable_declaration_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVARTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableVariable_declarationParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariableAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariableVariable_declarationParserRuleCall_2_1_0 = (RuleCall)cVariableAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//variable_declaration_part:
		//	VAR variable+=variable_declaration (";" variable+=variable_declaration)* ";";
		@Override public ParserRule getRule() { return rule; }
		
		//VAR variable+=variable_declaration (";" variable+=variable_declaration)* ";"
		public Group getGroup() { return cGroup; }
		
		//VAR
		public RuleCall getVARTerminalRuleCall_0() { return cVARTerminalRuleCall_0; }
		
		//variable+=variable_declaration
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//variable_declaration
		public RuleCall getVariableVariable_declarationParserRuleCall_1_0() { return cVariableVariable_declarationParserRuleCall_1_0; }
		
		//(";" variable+=variable_declaration)*
		public Group getGroup_2() { return cGroup_2; }
		
		//";"
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//variable+=variable_declaration
		public Assignment getVariableAssignment_2_1() { return cVariableAssignment_2_1; }
		
		//variable_declaration
		public RuleCall getVariableVariable_declarationParserRuleCall_2_1_0() { return cVariableVariable_declarationParserRuleCall_2_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class Variable_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.variable_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifier_listParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesTypeParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		
		//variable_declaration:
		//	identifier_list ":" types+=type;
		@Override public ParserRule getRule() { return rule; }
		
		//identifier_list ":" types+=type
		public Group getGroup() { return cGroup; }
		
		//identifier_list
		public RuleCall getIdentifier_listParserRuleCall_0() { return cIdentifier_listParserRuleCall_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//types+=type
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//type
		public RuleCall getTypesTypeParserRuleCall_2_0() { return cTypesTypeParserRuleCall_2_0; }
	}
	public class Compound_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.compound_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBeginKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSequenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSequenceStatementsParserRuleCall_1_0 = (RuleCall)cSequenceAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//compound_statement:
		//	"begin" sequence=statements "end";
		@Override public ParserRule getRule() { return rule; }
		
		//"begin" sequence=statements "end"
		public Group getGroup() { return cGroup; }
		
		//"begin"
		public Keyword getBeginKeyword_0() { return cBeginKeyword_0; }
		
		//sequence=statements
		public Assignment getSequenceAssignment_1() { return cSequenceAssignment_1; }
		
		//statements
		public RuleCall getSequenceStatementsParserRuleCall_1_0() { return cSequenceStatementsParserRuleCall_1_0; }
		
		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}
	public class StatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.statements");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatementsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_0_0 = (RuleCall)cStatementsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_1_1_0 = (RuleCall)cStatementsAssignment_1_1.eContents().get(0);
		
		//statements:
		//	statements+=statement (";" statements+=statement)*;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=statement (";" statements+=statement)*
		public Group getGroup() { return cGroup; }
		
		//statements+=statement
		public Assignment getStatementsAssignment_0() { return cStatementsAssignment_0; }
		
		//statement
		public RuleCall getStatementsStatementParserRuleCall_0_0() { return cStatementsStatementParserRuleCall_0_0; }
		
		//(";" statements+=statement)*
		public Group getGroup_1() { return cGroup_1; }
		
		//";"
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }
		
		//statements+=statement
		public Assignment getStatementsAssignment_1_1() { return cStatementsAssignment_1_1; }
		
		//statement
		public RuleCall getStatementsStatementParserRuleCall_1_1_0() { return cStatementsStatementParserRuleCall_1_1_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cLabelAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cLabelLabelParserRuleCall_0_0_0 = (RuleCall)cLabelAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cStatementAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cStatementUnlabelled_statementParserRuleCall_0_2_0 = (RuleCall)cStatementAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cStatementAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cStatementAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementUnlabelled_statementParserRuleCall_1_1_0 = (RuleCall)cStatementAssignment_1_1.eContents().get(0);
		
		//statement:
		//	label=label ":" statement+=unlabelled_statement | {statement} statement+=unlabelled_statement?;
		@Override public ParserRule getRule() { return rule; }
		
		//label=label ":" statement+=unlabelled_statement | {statement} statement+=unlabelled_statement?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//label=label ":" statement+=unlabelled_statement
		public Group getGroup_0() { return cGroup_0; }
		
		//label=label
		public Assignment getLabelAssignment_0_0() { return cLabelAssignment_0_0; }
		
		//label
		public RuleCall getLabelLabelParserRuleCall_0_0_0() { return cLabelLabelParserRuleCall_0_0_0; }
		
		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }
		
		//statement+=unlabelled_statement
		public Assignment getStatementAssignment_0_2() { return cStatementAssignment_0_2; }
		
		//unlabelled_statement
		public RuleCall getStatementUnlabelled_statementParserRuleCall_0_2_0() { return cStatementUnlabelled_statementParserRuleCall_0_2_0; }
		
		//{statement} statement+=unlabelled_statement?
		public Group getGroup_1() { return cGroup_1; }
		
		//{statement}
		public Action getStatementAction_1_0() { return cStatementAction_1_0; }
		
		//statement+=unlabelled_statement?
		public Assignment getStatementAssignment_1_1() { return cStatementAssignment_1_1; }
		
		//unlabelled_statement
		public RuleCall getStatementUnlabelled_statementParserRuleCall_1_1_0() { return cStatementUnlabelled_statementParserRuleCall_1_1_0; }
	}
	public class Unlabelled_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unlabelled_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cSimpleAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleSimple_statementParserRuleCall_0_0 = (RuleCall)cSimpleAssignment_0.eContents().get(0);
		private final Assignment cStructuredAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStructuredStructured_statementParserRuleCall_1_0 = (RuleCall)cStructuredAssignment_1.eContents().get(0);
		
		//unlabelled_statement:
		//	simple=simple_statement | structured=structured_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//simple=simple_statement | structured=structured_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//simple=simple_statement
		public Assignment getSimpleAssignment_0() { return cSimpleAssignment_0; }
		
		//simple_statement
		public RuleCall getSimpleSimple_statementParserRuleCall_0_0() { return cSimpleSimple_statementParserRuleCall_0_0; }
		
		//structured=structured_statement
		public Assignment getStructuredAssignment_1() { return cStructuredAssignment_1; }
		
		//structured_statement
		public RuleCall getStructuredStructured_statementParserRuleCall_1_0() { return cStructuredStructured_statementParserRuleCall_1_0; }
	}
	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.label");
		private final Assignment cNumberAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNumberUnsigned_integerParserRuleCall_0 = (RuleCall)cNumberAssignment.eContents().get(0);
		
		//label:
		//	number=unsigned_integer;
		@Override public ParserRule getRule() { return rule; }
		
		//number=unsigned_integer
		public Assignment getNumberAssignment() { return cNumberAssignment; }
		
		//unsigned_integer
		public RuleCall getNumberUnsigned_integerParserRuleCall_0() { return cNumberUnsigned_integerParserRuleCall_0; }
	}
	public class Simple_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.simple_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAssignmentAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentAssignment_statementParserRuleCall_0_0 = (RuleCall)cAssignmentAssignment_0.eContents().get(0);
		private final Assignment cProcedureAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cProcedureProcedure_statementParserRuleCall_1_0 = (RuleCall)cProcedureAssignment_1.eContents().get(0);
		private final Assignment cGotoAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cGotoGoto_statementParserRuleCall_2_0 = (RuleCall)cGotoAssignment_2.eContents().get(0);
		
		//simple_statement:
		//	assignment=assignment_statement | procedure=procedure_statement | goto=goto_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//assignment=assignment_statement | procedure=procedure_statement | goto=goto_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//assignment=assignment_statement
		public Assignment getAssignmentAssignment_0() { return cAssignmentAssignment_0; }
		
		//assignment_statement
		public RuleCall getAssignmentAssignment_statementParserRuleCall_0_0() { return cAssignmentAssignment_statementParserRuleCall_0_0; }
		
		//procedure=procedure_statement
		public Assignment getProcedureAssignment_1() { return cProcedureAssignment_1; }
		
		//procedure_statement
		public RuleCall getProcedureProcedure_statementParserRuleCall_1_0() { return cProcedureProcedure_statementParserRuleCall_1_0; }
		
		//goto=goto_statement
		public Assignment getGotoAssignment_2() { return cGotoAssignment_2; }
		
		//goto_statement
		public RuleCall getGotoGoto_statementParserRuleCall_2_0() { return cGotoGoto_statementParserRuleCall_2_0; }
	}
	public class Assignment_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.assignment_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//assignment_statement:
		//	variable=variable ASSIGN expression=expression;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=variable ASSIGN expression=expression
		public Group getGroup() { return cGroup; }
		
		//variable=variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//ASSIGN
		public RuleCall getASSIGNTerminalRuleCall_1() { return cASSIGNTerminalRuleCall_1; }
		
		//expression=expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cCommercialAtKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cNamesAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_0_0_1_0 = (RuleCall)cNamesAssignment_0_0_1.eContents().get(0);
		private final Assignment cNamesAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_0_1_0 = (RuleCall)cNamesAssignment_0_1.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0_1_0 = (RuleCall)cExpressionAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_0_2 = (Group)cGroup_1_0.eContents().get(2);
		private final Keyword cCommaKeyword_1_0_2_0 = (Keyword)cGroup_1_0_2.eContents().get(0);
		private final Assignment cExpressionAssignment_1_0_2_1 = (Assignment)cGroup_1_0_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0_2_1_0 = (RuleCall)cExpressionAssignment_1_0_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftParenthesisFullStopKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpressionAssignment_1_1_1.eContents().get(0);
		private final Group cGroup_1_1_2 = (Group)cGroup_1_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_1_2_0 = (Keyword)cGroup_1_1_2.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_2_1 = (Assignment)cGroup_1_1_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_2_1_0 = (RuleCall)cExpressionAssignment_1_1_2_1.eContents().get(0);
		private final Keyword cFullStopRightParenthesisKeyword_1_1_3 = (Keyword)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Keyword cFullStopKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cNamesAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_2_1_0 = (RuleCall)cNamesAssignment_1_2_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		
		//variable:
		//	('@' names+=ID | names+=ID) ('[' expression+=expression ("," expression+=expression)* ']' | "(."
		//	expression+=expression ("," expression+=expression)* ".)" | "." names+=ID | "^")*;
		@Override public ParserRule getRule() { return rule; }
		
		//('@' names+=ID | names+=ID) ('[' expression+=expression ("," expression+=expression)* ']' | "(." expression+=expression
		//("," expression+=expression)* ".)" | "." names+=ID | "^")*
		public Group getGroup() { return cGroup; }
		
		//'@' names+=ID | names+=ID
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'@' names+=ID
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0_0_0() { return cCommercialAtKeyword_0_0_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_0_0_1() { return cNamesAssignment_0_0_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0_1_0() { return cNamesIDTerminalRuleCall_0_0_1_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_0_1() { return cNamesAssignment_0_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_1_0() { return cNamesIDTerminalRuleCall_0_1_0; }
		
		//('[' expression+=expression ("," expression+=expression)* ']' | "(." expression+=expression (","
		//expression+=expression)* ".)" | "." names+=ID | "^")*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'[' expression+=expression ("," expression+=expression)* ']'
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0_0() { return cLeftSquareBracketKeyword_1_0_0; }
		
		//expression+=expression
		public Assignment getExpressionAssignment_1_0_1() { return cExpressionAssignment_1_0_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0_1_0() { return cExpressionExpressionParserRuleCall_1_0_1_0; }
		
		//("," expression+=expression)*
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//","
		public Keyword getCommaKeyword_1_0_2_0() { return cCommaKeyword_1_0_2_0; }
		
		//expression+=expression
		public Assignment getExpressionAssignment_1_0_2_1() { return cExpressionAssignment_1_0_2_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0_2_1_0() { return cExpressionExpressionParserRuleCall_1_0_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_0_3() { return cRightSquareBracketKeyword_1_0_3; }
		
		//"(." expression+=expression ("," expression+=expression)* ".)"
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//"(."
		public Keyword getLeftParenthesisFullStopKeyword_1_1_0() { return cLeftParenthesisFullStopKeyword_1_1_0; }
		
		//expression+=expression
		public Assignment getExpressionAssignment_1_1_1() { return cExpressionAssignment_1_1_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_1_0; }
		
		//("," expression+=expression)*
		public Group getGroup_1_1_2() { return cGroup_1_1_2; }
		
		//","
		public Keyword getCommaKeyword_1_1_2_0() { return cCommaKeyword_1_1_2_0; }
		
		//expression+=expression
		public Assignment getExpressionAssignment_1_1_2_1() { return cExpressionAssignment_1_1_2_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_2_1_0() { return cExpressionExpressionParserRuleCall_1_1_2_1_0; }
		
		//".)"
		public Keyword getFullStopRightParenthesisKeyword_1_1_3() { return cFullStopRightParenthesisKeyword_1_1_3; }
		
		//"." names+=ID
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//"."
		public Keyword getFullStopKeyword_1_2_0() { return cFullStopKeyword_1_2_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_1_2_1() { return cNamesAssignment_1_2_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_2_1_0() { return cNamesIDTerminalRuleCall_1_2_1_0; }
		
		//"^"
		public Keyword getCircumflexAccentKeyword_1_3() { return cCircumflexAccentKeyword_1_3; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsSimple_expressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorsRelational_operatorParserRuleCall_1_0_0 = (RuleCall)cOperatorsAssignment_1_0.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//expression:
		//	expressions+=simple_expression (operators+=relational_operator expressions+=expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//expressions+=simple_expression (operators+=relational_operator expressions+=expression)?
		public Group getGroup() { return cGroup; }
		
		//expressions+=simple_expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }
		
		//simple_expression
		public RuleCall getExpressionsSimple_expressionParserRuleCall_0_0() { return cExpressionsSimple_expressionParserRuleCall_0_0; }
		
		//(operators+=relational_operator expressions+=expression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//operators+=relational_operator
		public Assignment getOperatorsAssignment_1_0() { return cOperatorsAssignment_1_0; }
		
		//relational_operator
		public RuleCall getOperatorsRelational_operatorParserRuleCall_1_0_0() { return cOperatorsRelational_operatorParserRuleCall_1_0_0; }
		
		//expressions+=expression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }
		
		//expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_0; }
	}
	public class Simple_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.simple_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTermsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTermsTermParserRuleCall_0_0 = (RuleCall)cTermsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorsAdditive_operatorParserRuleCall_1_0_0 = (RuleCall)cOperatorsAssignment_1_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionSimple_expressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		
		//simple_expression:
		//	terms+=term (operators+=additive_operator expression+=simple_expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//terms+=term (operators+=additive_operator expression+=simple_expression)?
		public Group getGroup() { return cGroup; }
		
		//terms+=term
		public Assignment getTermsAssignment_0() { return cTermsAssignment_0; }
		
		//term
		public RuleCall getTermsTermParserRuleCall_0_0() { return cTermsTermParserRuleCall_0_0; }
		
		//(operators+=additive_operator expression+=simple_expression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//operators+=additive_operator
		public Assignment getOperatorsAssignment_1_0() { return cOperatorsAssignment_1_0; }
		
		//additive_operator
		public RuleCall getOperatorsAdditive_operatorParserRuleCall_1_0_0() { return cOperatorsAdditive_operatorParserRuleCall_1_0_0; }
		
		//expression+=simple_expression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }
		
		//simple_expression
		public RuleCall getExpressionSimple_expressionParserRuleCall_1_1_0() { return cExpressionSimple_expressionParserRuleCall_1_1_0; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFactorsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFactorsSigned_factorParserRuleCall_0_0 = (RuleCall)cFactorsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorsMultiplicative_operatorParserRuleCall_1_0_0 = (RuleCall)cOperatorsAssignment_1_0.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsTermParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		
		//term:
		//	factors+=signed_factor (operators+=multiplicative_operator terms+=term)?;
		@Override public ParserRule getRule() { return rule; }
		
		//factors+=signed_factor (operators+=multiplicative_operator terms+=term)?
		public Group getGroup() { return cGroup; }
		
		//factors+=signed_factor
		public Assignment getFactorsAssignment_0() { return cFactorsAssignment_0; }
		
		//signed_factor
		public RuleCall getFactorsSigned_factorParserRuleCall_0_0() { return cFactorsSigned_factorParserRuleCall_0_0; }
		
		//(operators+=multiplicative_operator terms+=term)?
		public Group getGroup_1() { return cGroup_1; }
		
		//operators+=multiplicative_operator
		public Assignment getOperatorsAssignment_1_0() { return cOperatorsAssignment_1_0; }
		
		//multiplicative_operator
		public RuleCall getOperatorsMultiplicative_operatorParserRuleCall_1_0_0() { return cOperatorsMultiplicative_operatorParserRuleCall_1_0_0; }
		
		//terms+=term
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }
		
		//term
		public RuleCall getTermsTermParserRuleCall_1_1_0() { return cTermsTermParserRuleCall_1_1_0; }
	}
	public class Signed_factorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.signed_factor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cOperatorsAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cOperatorsPLUSTerminalRuleCall_0_0_0 = (RuleCall)cOperatorsAssignment_0_0.eContents().get(0);
		private final Assignment cOperatorsAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cOperatorsMINUSTerminalRuleCall_0_1_0 = (RuleCall)cOperatorsAssignment_0_1.eContents().get(0);
		private final Assignment cFactorsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFactorsFactorParserRuleCall_1_0 = (RuleCall)cFactorsAssignment_1.eContents().get(0);
		
		//signed_factor:
		//	(operators+=PLUS | operators+=MINUS)? factors+=factor;
		@Override public ParserRule getRule() { return rule; }
		
		//(operators+=PLUS | operators+=MINUS)? factors+=factor
		public Group getGroup() { return cGroup; }
		
		//(operators+=PLUS | operators+=MINUS)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//operators+=PLUS
		public Assignment getOperatorsAssignment_0_0() { return cOperatorsAssignment_0_0; }
		
		//PLUS
		public RuleCall getOperatorsPLUSTerminalRuleCall_0_0_0() { return cOperatorsPLUSTerminalRuleCall_0_0_0; }
		
		//operators+=MINUS
		public Assignment getOperatorsAssignment_0_1() { return cOperatorsAssignment_0_1; }
		
		//MINUS
		public RuleCall getOperatorsMINUSTerminalRuleCall_0_1_0() { return cOperatorsMINUSTerminalRuleCall_0_1_0; }
		
		//factors+=factor
		public Assignment getFactorsAssignment_1() { return cFactorsAssignment_1; }
		
		//factor
		public RuleCall getFactorsFactorParserRuleCall_1_0() { return cFactorsFactorParserRuleCall_1_0; }
	}
	public class FactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.factor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cConstantAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cConstantUnsigned_constantParserRuleCall_2_0 = (RuleCall)cConstantAssignment_2.eContents().get(0);
		private final Assignment cSetAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cSetSetParserRuleCall_3_0 = (RuleCall)cSetAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cNOTTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cFactorAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cFactorFactorParserRuleCall_4_1_0 = (RuleCall)cFactorAssignment_4_1.eContents().get(0);
		private final Assignment cBooleanAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cBooleanBoolParserRuleCall_5_0 = (RuleCall)cBooleanAssignment_5.eContents().get(0);
		
		//factor:
		//	variable=variable
		//	| "(" expression=expression ")"
		//	//| functionDesignator
		//	| constant=unsigned_constant
		//	| set=set
		//	| NOT factor=factor
		//	| boolean+=bool;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=variable | "(" expression=expression ")" //| functionDesignator
		//| constant=unsigned_constant | set=set | NOT factor=factor | boolean+=bool
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//variable=variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//"(" expression=expression ")"
		public Group getGroup_1() { return cGroup_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//expression=expression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//constant=unsigned_constant
		public Assignment getConstantAssignment_2() { return cConstantAssignment_2; }
		
		//unsigned_constant
		public RuleCall getConstantUnsigned_constantParserRuleCall_2_0() { return cConstantUnsigned_constantParserRuleCall_2_0; }
		
		//set=set
		public Assignment getSetAssignment_3() { return cSetAssignment_3; }
		
		//set
		public RuleCall getSetSetParserRuleCall_3_0() { return cSetSetParserRuleCall_3_0; }
		
		//NOT factor=factor
		public Group getGroup_4() { return cGroup_4; }
		
		//NOT
		public RuleCall getNOTTerminalRuleCall_4_0() { return cNOTTerminalRuleCall_4_0; }
		
		//factor=factor
		public Assignment getFactorAssignment_4_1() { return cFactorAssignment_4_1; }
		
		//factor
		public RuleCall getFactorFactorParserRuleCall_4_1_0() { return cFactorFactorParserRuleCall_4_1_0; }
		
		//boolean+=bool
		public Assignment getBooleanAssignment_5() { return cBooleanAssignment_5; }
		
		//bool
		public RuleCall getBooleanBoolParserRuleCall_5_0() { return cBooleanBoolParserRuleCall_5_0; }
	}
	public class SetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.set");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cElementsAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cElementsElementListParserRuleCall_0_1_0 = (RuleCall)cElementsAssignment_0_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cElementsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cElementsElementListParserRuleCall_1_1_0 = (RuleCall)cElementsAssignment_1_1.eContents().get(0);
		private final Keyword cFullStopRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//set:
		//	"[" elements+=elementList "]"
		//	| "(." elements+=elementList ".)";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" elements+=elementList "]" | "(." elements+=elementList ".)"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"[" elements+=elementList "]"
		public Group getGroup_0() { return cGroup_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0_0() { return cLeftSquareBracketKeyword_0_0; }
		
		//elements+=elementList
		public Assignment getElementsAssignment_0_1() { return cElementsAssignment_0_1; }
		
		//elementList
		public RuleCall getElementsElementListParserRuleCall_0_1_0() { return cElementsElementListParserRuleCall_0_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_0_2() { return cRightSquareBracketKeyword_0_2; }
		
		//"(." elements+=elementList ".)"
		public Group getGroup_1() { return cGroup_1; }
		
		//"(."
		public Keyword getLeftParenthesisFullStopKeyword_1_0() { return cLeftParenthesisFullStopKeyword_1_0; }
		
		//elements+=elementList
		public Assignment getElementsAssignment_1_1() { return cElementsAssignment_1_1; }
		
		//elementList
		public RuleCall getElementsElementListParserRuleCall_1_1_0() { return cElementsElementListParserRuleCall_1_1_0; }
		
		//".)"
		public Keyword getFullStopRightParenthesisKeyword_1_2() { return cFullStopRightParenthesisKeyword_1_2; }
	}
	public class ElementListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.elementList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cElementsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cElementsElementParserRuleCall_0_0 = (RuleCall)cElementsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cElementsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cElementsElementParserRuleCall_1_1_0 = (RuleCall)cElementsAssignment_1_1.eContents().get(0);
		
		//elementList:
		//	elements+=element ("," elements+=element)*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=element ("," elements+=element)*
		public Group getGroup() { return cGroup; }
		
		//elements+=element
		public Assignment getElementsAssignment_0() { return cElementsAssignment_0; }
		
		//element
		public RuleCall getElementsElementParserRuleCall_0_0() { return cElementsElementParserRuleCall_0_0; }
		
		//("," elements+=element)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//elements+=element
		public Assignment getElementsAssignment_1_1() { return cElementsAssignment_1_1; }
		
		//element
		public RuleCall getElementsElementParserRuleCall_1_1_0() { return cElementsElementParserRuleCall_1_1_0; }
	}
	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.element");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cDotdotAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cDotdotDOTDOTTerminalRuleCall_1_0_0 = (RuleCall)cDotdotAssignment_1_0.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//element:
		//	expressions+=expression (dotdot+=DOTDOT expressions+=expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//expressions+=expression (dotdot+=DOTDOT expressions+=expression)?
		public Group getGroup() { return cGroup; }
		
		//expressions+=expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }
		
		//expression
		public RuleCall getExpressionsExpressionParserRuleCall_0_0() { return cExpressionsExpressionParserRuleCall_0_0; }
		
		//(dotdot+=DOTDOT expressions+=expression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//dotdot+=DOTDOT
		public Assignment getDotdotAssignment_1_0() { return cDotdotAssignment_1_0; }
		
		//DOTDOT
		public RuleCall getDotdotDOTDOTTerminalRuleCall_1_0_0() { return cDotdotDOTDOTTerminalRuleCall_1_0_0; }
		
		//expressions+=expression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }
		
		//expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_0; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTypeSimple_typeParserRuleCall_0 = (RuleCall)cTypeAssignment.eContents().get(0);
		
		//type:
		//	type+=simple_type
		//	//| type+=structured_type
		//	//| type+=pointer_type
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//type+=simple_type
		public Assignment getTypeAssignment() { return cTypeAssignment; }
		
		//simple_type
		public RuleCall getTypeSimple_typeParserRuleCall_0() { return cTypeSimple_typeParserRuleCall_0; }
	}
	public class Simple_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.simple_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTypesAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTypesScalar_typeParserRuleCall_0_0 = (RuleCall)cTypesAssignment_0.eContents().get(0);
		private final Assignment cTypesAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTypesSubrange_typeParserRuleCall_1_0 = (RuleCall)cTypesAssignment_1.eContents().get(0);
		private final Assignment cTypesAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cTypesType_identifierParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		private final Assignment cTypesAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cTypesString_typeParserRuleCall_3_0 = (RuleCall)cTypesAssignment_3.eContents().get(0);
		
		//simple_type:
		//	types+=scalar_type
		//	| types+=subrange_type
		//	| types+=type_identifier
		//	| types+=string_type;
		@Override public ParserRule getRule() { return rule; }
		
		//types+=scalar_type | types+=subrange_type | types+=type_identifier | types+=string_type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//types+=scalar_type
		public Assignment getTypesAssignment_0() { return cTypesAssignment_0; }
		
		//scalar_type
		public RuleCall getTypesScalar_typeParserRuleCall_0_0() { return cTypesScalar_typeParserRuleCall_0_0; }
		
		//types+=subrange_type
		public Assignment getTypesAssignment_1() { return cTypesAssignment_1; }
		
		//subrange_type
		public RuleCall getTypesSubrange_typeParserRuleCall_1_0() { return cTypesSubrange_typeParserRuleCall_1_0; }
		
		//types+=type_identifier
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//type_identifier
		public RuleCall getTypesType_identifierParserRuleCall_2_0() { return cTypesType_identifierParserRuleCall_2_0; }
		
		//types+=string_type
		public Assignment getTypesAssignment_3() { return cTypesAssignment_3; }
		
		//string_type
		public RuleCall getTypesString_typeParserRuleCall_3_0() { return cTypesString_typeParserRuleCall_3_0; }
	}
	public class Scalar_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.scalar_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIdentifier_listParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//scalar_type:
		//	"(" identifier_list ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"(" identifier_list ")"
		public Group getGroup() { return cGroup; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//identifier_list
		public RuleCall getIdentifier_listParserRuleCall_1() { return cIdentifier_listParserRuleCall_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class Subrange_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.subrange_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantsConstantParserRuleCall_0_0 = (RuleCall)cConstantsAssignment_0.eContents().get(0);
		private final RuleCall cDOTDOTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cConstantsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConstantsConstantParserRuleCall_2_0 = (RuleCall)cConstantsAssignment_2.eContents().get(0);
		
		//subrange_type:
		//	constants+=constant DOTDOT constants+=constant;
		@Override public ParserRule getRule() { return rule; }
		
		//constants+=constant DOTDOT constants+=constant
		public Group getGroup() { return cGroup; }
		
		//constants+=constant
		public Assignment getConstantsAssignment_0() { return cConstantsAssignment_0; }
		
		//constant
		public RuleCall getConstantsConstantParserRuleCall_0_0() { return cConstantsConstantParserRuleCall_0_0; }
		
		//DOTDOT
		public RuleCall getDOTDOTTerminalRuleCall_1() { return cDOTDOTTerminalRuleCall_1; }
		
		//constants+=constant
		public Assignment getConstantsAssignment_2() { return cConstantsAssignment_2; }
		
		//constant
		public RuleCall getConstantsConstantParserRuleCall_2_0() { return cConstantsConstantParserRuleCall_2_0; }
	}
	public class Type_identifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type_identifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cAlternatives.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cTypeCHARKeyword_1_0_0 = (Keyword)cTypeAssignment_1_0.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cTypeBooleanKeyword_1_1_0 = (Keyword)cTypeAssignment_1_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final Keyword cTypeIntegerKeyword_1_2_0 = (Keyword)cTypeAssignment_1_2.eContents().get(0);
		private final Assignment cTypeAssignment_1_3 = (Assignment)cAlternatives_1.eContents().get(3);
		private final Keyword cTypeRealKeyword_1_3_0 = (Keyword)cTypeAssignment_1_3.eContents().get(0);
		private final Assignment cTypeAssignment_1_4 = (Assignment)cAlternatives_1.eContents().get(4);
		private final Keyword cTypeStringKeyword_1_4_0 = (Keyword)cTypeAssignment_1_4.eContents().get(0);
		
		//type_identifier:
		//	names+=ID
		//	| (type+='CHAR' | type+='boolean' | type+='integer' | type+='real' | type+='string');
		@Override public ParserRule getRule() { return rule; }
		
		//names+=ID | (type+='CHAR' | type+='boolean' | type+='integer' | type+='real' | type+='string')
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//names+=ID
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0() { return cNamesIDTerminalRuleCall_0_0; }
		
		//(type+='CHAR' | type+='boolean' | type+='integer' | type+='real' | type+='string')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//type+='CHAR'
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//'CHAR'
		public Keyword getTypeCHARKeyword_1_0_0() { return cTypeCHARKeyword_1_0_0; }
		
		//type+='boolean'
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//'boolean'
		public Keyword getTypeBooleanKeyword_1_1_0() { return cTypeBooleanKeyword_1_1_0; }
		
		//type+='integer'
		public Assignment getTypeAssignment_1_2() { return cTypeAssignment_1_2; }
		
		//'integer'
		public Keyword getTypeIntegerKeyword_1_2_0() { return cTypeIntegerKeyword_1_2_0; }
		
		//type+='real'
		public Assignment getTypeAssignment_1_3() { return cTypeAssignment_1_3; }
		
		//'real'
		public Keyword getTypeRealKeyword_1_3_0() { return cTypeRealKeyword_1_3_0; }
		
		//type+='string'
		public Assignment getTypeAssignment_1_4() { return cTypeAssignment_1_4; }
		
		//'string'
		public Keyword getTypeStringKeyword_1_4_0() { return cTypeStringKeyword_1_4_0; }
	}
	public class String_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.string_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStringKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cNamesAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_2_0_0 = (RuleCall)cNamesAssignment_2_0.eContents().get(0);
		private final Assignment cNumberAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cNumberUnsigned_numberParserRuleCall_2_1_0 = (RuleCall)cNumberAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//string_type:
		//	'string' '[' (names+=ID | number+=unsigned_number) ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'string' '[' (names+=ID | number+=unsigned_number) ']'
		public Group getGroup() { return cGroup; }
		
		//'string'
		public Keyword getStringKeyword_0() { return cStringKeyword_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//names+=ID | number+=unsigned_number
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//names+=ID
		public Assignment getNamesAssignment_2_0() { return cNamesAssignment_2_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_2_0_0() { return cNamesIDTerminalRuleCall_2_0_0; }
		
		//number+=unsigned_number
		public Assignment getNumberAssignment_2_1() { return cNumberAssignment_2_1; }
		
		//unsigned_number
		public RuleCall getNumberUnsigned_numberParserRuleCall_2_1_0() { return cNumberUnsigned_numberParserRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class Unsigned_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unsigned_constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNumberAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNumberUnsigned_numberParserRuleCall_0_0 = (RuleCall)cNumberAssignment_0.eContents().get(0);
		private final Assignment cCharAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cCharConstant_chrParserRuleCall_1_0 = (RuleCall)cCharAssignment_1.eContents().get(0);
		private final Assignment cStringAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cStringSTRINGTerminalRuleCall_2_0 = (RuleCall)cStringAssignment_2.eContents().get(0);
		private final Assignment cNilAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cNilNILTerminalRuleCall_3_0 = (RuleCall)cNilAssignment_3.eContents().get(0);
		
		//unsigned_constant:
		//	number+=unsigned_number
		//	| char+=constant_chr
		//	| string+=STRING
		//	| nil+=NIL;
		@Override public ParserRule getRule() { return rule; }
		
		//number+=unsigned_number | char+=constant_chr | string+=STRING | nil+=NIL
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//number+=unsigned_number
		public Assignment getNumberAssignment_0() { return cNumberAssignment_0; }
		
		//unsigned_number
		public RuleCall getNumberUnsigned_numberParserRuleCall_0_0() { return cNumberUnsigned_numberParserRuleCall_0_0; }
		
		//char+=constant_chr
		public Assignment getCharAssignment_1() { return cCharAssignment_1; }
		
		//constant_chr
		public RuleCall getCharConstant_chrParserRuleCall_1_0() { return cCharConstant_chrParserRuleCall_1_0; }
		
		//string+=STRING
		public Assignment getStringAssignment_2() { return cStringAssignment_2; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_2_0() { return cStringSTRINGTerminalRuleCall_2_0; }
		
		//nil+=NIL
		public Assignment getNilAssignment_3() { return cNilAssignment_3; }
		
		//NIL
		public RuleCall getNilNILTerminalRuleCall_3_0() { return cNilNILTerminalRuleCall_3_0; }
	}
	public class Unsigned_numberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unsigned_number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNumbersAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNumbersUnsigned_integerParserRuleCall_0_0 = (RuleCall)cNumbersAssignment_0.eContents().get(0);
		private final Assignment cNumbersAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNumbersUnsigned_realParserRuleCall_1_0 = (RuleCall)cNumbersAssignment_1.eContents().get(0);
		
		//unsigned_number:
		//	numbers+=unsigned_integer
		//	| numbers+=unsigned_real;
		@Override public ParserRule getRule() { return rule; }
		
		//numbers+=unsigned_integer | numbers+=unsigned_real
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//numbers+=unsigned_integer
		public Assignment getNumbersAssignment_0() { return cNumbersAssignment_0; }
		
		//unsigned_integer
		public RuleCall getNumbersUnsigned_integerParserRuleCall_0_0() { return cNumbersUnsigned_integerParserRuleCall_0_0; }
		
		//numbers+=unsigned_real
		public Assignment getNumbersAssignment_1() { return cNumbersAssignment_1; }
		
		//unsigned_real
		public RuleCall getNumbersUnsigned_realParserRuleCall_1_0() { return cNumbersUnsigned_realParserRuleCall_1_0; }
	}
	public class Constant_chrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.constant_chr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cChrKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNumbersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNumbersUnsigned_integerParserRuleCall_2_0 = (RuleCall)cNumbersAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//constant_chr:
		//	"chr" "(" numbers+=unsigned_integer ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"chr" "(" numbers+=unsigned_integer ")"
		public Group getGroup() { return cGroup; }
		
		//"chr"
		public Keyword getChrKeyword_0() { return cChrKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//numbers+=unsigned_integer
		public Assignment getNumbersAssignment_2() { return cNumbersAssignment_2; }
		
		//unsigned_integer
		public RuleCall getNumbersUnsigned_integerParserRuleCall_2_0() { return cNumbersUnsigned_integerParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Procedure_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypesParameter_listParserRuleCall_1_1_0 = (RuleCall)cTypesAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//procedure_statement:
		//	names+=ID ('(' types+=parameter_list ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//names+=ID ('(' types+=parameter_list ')')?
		public Group getGroup() { return cGroup; }
		
		//names+=ID
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0() { return cNamesIDTerminalRuleCall_0_0; }
		
		//('(' types+=parameter_list ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//types+=parameter_list
		public Assignment getTypesAssignment_1_1() { return cTypesAssignment_1_1; }
		
		//parameter_list
		public RuleCall getTypesParameter_listParserRuleCall_1_1_0() { return cTypesParameter_listParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class Parameter_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.parameter_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cActual_parameterParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypesActual_parameterParserRuleCall_1_1_0 = (RuleCall)cTypesAssignment_1_1.eContents().get(0);
		
		//parameter_list:
		//	actual_parameter (',' types+=actual_parameter)*;
		@Override public ParserRule getRule() { return rule; }
		
		//actual_parameter (',' types+=actual_parameter)*
		public Group getGroup() { return cGroup; }
		
		//actual_parameter
		public RuleCall getActual_parameterParserRuleCall_0() { return cActual_parameterParserRuleCall_0; }
		
		//(',' types+=actual_parameter)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//types+=actual_parameter
		public Assignment getTypesAssignment_1_1() { return cTypesAssignment_1_1; }
		
		//actual_parameter
		public RuleCall getTypesActual_parameterParserRuleCall_1_1_0() { return cTypesActual_parameterParserRuleCall_1_1_0; }
	}
	public class Actual_parameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.actual_parameter");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//actual_parameter:
		//	expression;
		@Override public ParserRule getRule() { return rule; }
		
		//expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}
	public class Goto_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.goto_statement");
		private final Keyword cGotoKeyword = (Keyword)rule.eContents().get(1);
		
		//goto_statement:
		//	"goto";
		@Override public ParserRule getRule() { return rule; }
		
		//"goto"
		public Keyword getGotoKeyword() { return cGotoKeyword; }
	}
	public class Structured_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.structured_statement");
		private final Keyword cStructuredKeyword = (Keyword)rule.eContents().get(1);
		
		//structured_statement:
		//	"structured";
		@Override public ParserRule getRule() { return rule; }
		
		//"structured"
		public Keyword getStructuredKeyword() { return cStructuredKeyword; }
	}
	public class Unsigned_integerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unsigned_integer");
		private final RuleCall cNUM_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//unsigned_integer:
		//	NUM_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//NUM_INT
		public RuleCall getNUM_INTTerminalRuleCall() { return cNUM_INTTerminalRuleCall; }
	}
	public class Unsigned_realElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unsigned_real");
		private final RuleCall cNUM_REALTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//unsigned_real:
		//	NUM_REAL;
		@Override public ParserRule getRule() { return rule; }
		
		//NUM_REAL
		public RuleCall getNUM_REALTerminalRuleCall() { return cNUM_REALTerminalRuleCall; }
	}
	public class Additive_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.additive_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPLUSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMINUSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cORTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//additive_operator:
		//	PLUS
		//	| MINUS
		//	| OR;
		@Override public ParserRule getRule() { return rule; }
		
		//PLUS | MINUS | OR
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS
		public RuleCall getPLUSTerminalRuleCall_0() { return cPLUSTerminalRuleCall_0; }
		
		//MINUS
		public RuleCall getMINUSTerminalRuleCall_1() { return cMINUSTerminalRuleCall_1; }
		
		//OR
		public RuleCall getORTerminalRuleCall_2() { return cORTerminalRuleCall_2; }
	}
	public class Multiplicative_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.multiplicative_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTARTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSLASHTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDIVTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMODTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cANDTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//multiplicative_operator:
		//	STAR
		//	| SLASH
		//	| DIV
		//	| MOD
		//	| AND;
		@Override public ParserRule getRule() { return rule; }
		
		//STAR | SLASH | DIV | MOD | AND
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STAR
		public RuleCall getSTARTerminalRuleCall_0() { return cSTARTerminalRuleCall_0; }
		
		//SLASH
		public RuleCall getSLASHTerminalRuleCall_1() { return cSLASHTerminalRuleCall_1; }
		
		//DIV
		public RuleCall getDIVTerminalRuleCall_2() { return cDIVTerminalRuleCall_2; }
		
		//MOD
		public RuleCall getMODTerminalRuleCall_3() { return cMODTerminalRuleCall_3; }
		
		//AND
		public RuleCall getANDTerminalRuleCall_4() { return cANDTerminalRuleCall_4; }
	}
	public class Relational_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.relational_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEQUALTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNOT_EQUALTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLTTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLETerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cGETerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cGTTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cINTerminalRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//relational_operator:
		//	EQUAL
		//	| NOT_EQUAL
		//	| LT
		//	| LE
		//	| GE
		//	| GT
		//	| IN;
		@Override public ParserRule getRule() { return rule; }
		
		//EQUAL | NOT_EQUAL | LT | LE | GE | GT | IN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUAL
		public RuleCall getEQUALTerminalRuleCall_0() { return cEQUALTerminalRuleCall_0; }
		
		//NOT_EQUAL
		public RuleCall getNOT_EQUALTerminalRuleCall_1() { return cNOT_EQUALTerminalRuleCall_1; }
		
		//LT
		public RuleCall getLTTerminalRuleCall_2() { return cLTTerminalRuleCall_2; }
		
		//LE
		public RuleCall getLETerminalRuleCall_3() { return cLETerminalRuleCall_3; }
		
		//GE
		public RuleCall getGETerminalRuleCall_4() { return cGETerminalRuleCall_4; }
		
		//GT
		public RuleCall getGTTerminalRuleCall_5() { return cGTTerminalRuleCall_5; }
		
		//IN
		public RuleCall getINTerminalRuleCall_6() { return cINTerminalRuleCall_6; }
	}
	public class Procedure_and_function_declaration_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_and_function_declaration_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cProcedure_or_function_declarationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//procedure_and_function_declaration_part:
		//	procedure_or_function_declaration ";";
		@Override public ParserRule getRule() { return rule; }
		
		//procedure_or_function_declaration ";"
		public Group getGroup() { return cGroup; }
		
		//procedure_or_function_declaration
		public RuleCall getProcedure_or_function_declarationParserRuleCall_0() { return cProcedure_or_function_declarationParserRuleCall_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}
	public class Procedure_or_function_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_or_function_declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProcedure_declarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunction_declarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//procedure_or_function_declaration:
		//	procedure_declaration | function_declaration;
		@Override public ParserRule getRule() { return rule; }
		
		//procedure_declaration | function_declaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//procedure_declaration
		public RuleCall getProcedure_declarationParserRuleCall_0() { return cProcedure_declarationParserRuleCall_0; }
		
		//function_declaration
		public RuleCall getFunction_declarationParserRuleCall_1() { return cFunction_declarationParserRuleCall_1; }
	}
	public class Procedure_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPROCEDURETerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNamesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_0 = (RuleCall)cNamesAssignment_1.eContents().get(0);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		//procedure_declaration:
		//	PROCEDURE names+=ID types+=formal_parameter_list? ';' block=block;
		@Override public ParserRule getRule() { return rule; }
		
		//PROCEDURE names+=ID types+=formal_parameter_list? ';' block=block
		public Group getGroup() { return cGroup; }
		
		//PROCEDURE
		public RuleCall getPROCEDURETerminalRuleCall_0() { return cPROCEDURETerminalRuleCall_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_1() { return cNamesAssignment_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_0() { return cNamesIDTerminalRuleCall_1_0; }
		
		//types+=formal_parameter_list?
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getTypesFormal_parameter_listParserRuleCall_2_0() { return cTypesFormal_parameter_listParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
		
		//block=block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}
	public class Type_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type_definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final RuleCall cEQUALTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cTypeParserRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cFunction_typeParserRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		private final RuleCall cProcedure_typeParserRuleCall_2_2 = (RuleCall)cAlternatives_2.eContents().get(2);
		
		//type_definition:
		//	names+=ID EQUAL (type | function_type | procedure_type);
		@Override public ParserRule getRule() { return rule; }
		
		//names+=ID EQUAL (type | function_type | procedure_type)
		public Group getGroup() { return cGroup; }
		
		//names+=ID
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0() { return cNamesIDTerminalRuleCall_0_0; }
		
		//EQUAL
		public RuleCall getEQUALTerminalRuleCall_1() { return cEQUALTerminalRuleCall_1; }
		
		//type | function_type | procedure_type
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//type
		public RuleCall getTypeParserRuleCall_2_0() { return cTypeParserRuleCall_2_0; }
		
		//function_type
		public RuleCall getFunction_typeParserRuleCall_2_1() { return cFunction_typeParserRuleCall_2_1; }
		
		//procedure_type
		public RuleCall getProcedure_typeParserRuleCall_2_2() { return cProcedure_typeParserRuleCall_2_2; }
	}
	public class Procedure_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProcedure_typeAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cPROCEDURETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		
		//procedure_type:
		//	{procedure_type} PROCEDURE types+=formal_parameter_list?;
		@Override public ParserRule getRule() { return rule; }
		
		//{procedure_type} PROCEDURE types+=formal_parameter_list?
		public Group getGroup() { return cGroup; }
		
		//{procedure_type}
		public Action getProcedure_typeAction_0() { return cProcedure_typeAction_0; }
		
		//PROCEDURE
		public RuleCall getPROCEDURETerminalRuleCall_1() { return cPROCEDURETerminalRuleCall_1; }
		
		//types+=formal_parameter_list?
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getTypesFormal_parameter_listParserRuleCall_2_0() { return cTypesFormal_parameter_listParserRuleCall_2_0; }
	}
	public class Function_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.function_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFUNCTIONTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNamesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_0 = (RuleCall)cNamesAssignment_1.eContents().get(0);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypesResult_typeParserRuleCall_4_0 = (RuleCall)cTypesAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBlockAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBlockBlockParserRuleCall_6_0 = (RuleCall)cBlockAssignment_6.eContents().get(0);
		
		//function_declaration:
		//	FUNCTION names+=ID types+=formal_parameter_list? ':'
		//	types+=result_type ';' block=block;
		@Override public ParserRule getRule() { return rule; }
		
		//FUNCTION names+=ID types+=formal_parameter_list? ':' types+=result_type ';' block=block
		public Group getGroup() { return cGroup; }
		
		//FUNCTION
		public RuleCall getFUNCTIONTerminalRuleCall_0() { return cFUNCTIONTerminalRuleCall_0; }
		
		//names+=ID
		public Assignment getNamesAssignment_1() { return cNamesAssignment_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_0() { return cNamesIDTerminalRuleCall_1_0; }
		
		//types+=formal_parameter_list?
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getTypesFormal_parameter_listParserRuleCall_2_0() { return cTypesFormal_parameter_listParserRuleCall_2_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//types+=result_type
		public Assignment getTypesAssignment_4() { return cTypesAssignment_4; }
		
		//result_type
		public RuleCall getTypesResult_typeParserRuleCall_4_0() { return cTypesResult_typeParserRuleCall_4_0; }
		
		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
		
		//block=block
		public Assignment getBlockAssignment_6() { return cBlockAssignment_6; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_6_0() { return cBlockBlockParserRuleCall_6_0; }
	}
	public class Function_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.function_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIDTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Assignment cTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypesFormal_parameter_listParserRuleCall_1_0 = (RuleCall)cTypesAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypesResult_typeParserRuleCall_3_0 = (RuleCall)cTypesAssignment_3.eContents().get(0);
		
		//function_type:
		//	names+=ID types+=formal_parameter_list? ':' types+=result_type;
		@Override public ParserRule getRule() { return rule; }
		
		//names+=ID types+=formal_parameter_list? ':' types+=result_type
		public Group getGroup() { return cGroup; }
		
		//names+=ID
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_0_0() { return cNamesIDTerminalRuleCall_0_0; }
		
		//types+=formal_parameter_list?
		public Assignment getTypesAssignment_1() { return cTypesAssignment_1; }
		
		//formal_parameter_list
		public RuleCall getTypesFormal_parameter_listParserRuleCall_1_0() { return cTypesFormal_parameter_listParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//types+=result_type
		public Assignment getTypesAssignment_3() { return cTypesAssignment_3; }
		
		//result_type
		public RuleCall getTypesResult_typeParserRuleCall_3_0() { return cTypesResult_typeParserRuleCall_3_0; }
	}
	public class Formal_parameter_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.formal_parameter_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cFormal_parameter_sectionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypesFormal_parameter_sectionParserRuleCall_2_1_0 = (RuleCall)cTypesAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//formal_parameter_list:
		//	'(' formal_parameter_section (';' types+=formal_parameter_section)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' formal_parameter_section (';' types+=formal_parameter_section)* ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//formal_parameter_section
		public RuleCall getFormal_parameter_sectionParserRuleCall_1() { return cFormal_parameter_sectionParserRuleCall_1; }
		
		//(';' types+=formal_parameter_section)*
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//types+=formal_parameter_section
		public Assignment getTypesAssignment_2_1() { return cTypesAssignment_2_1; }
		
		//formal_parameter_section
		public RuleCall getTypesFormal_parameter_sectionParserRuleCall_2_1_0() { return cTypesFormal_parameter_sectionParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Formal_parameter_sectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.formal_parameter_section");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParameter_groupParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cVARTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cParameter_groupParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cFUNCTIONTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cParameter_groupParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cPROCEDURETerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cParameter_groupParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		
		//formal_parameter_section:
		//	parameter_group
		//	| VAR parameter_group
		//	| FUNCTION parameter_group
		//	| PROCEDURE parameter_group;
		@Override public ParserRule getRule() { return rule; }
		
		//parameter_group | VAR parameter_group | FUNCTION parameter_group | PROCEDURE parameter_group
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//parameter_group
		public RuleCall getParameter_groupParserRuleCall_0() { return cParameter_groupParserRuleCall_0; }
		
		//VAR parameter_group
		public Group getGroup_1() { return cGroup_1; }
		
		//VAR
		public RuleCall getVARTerminalRuleCall_1_0() { return cVARTerminalRuleCall_1_0; }
		
		//parameter_group
		public RuleCall getParameter_groupParserRuleCall_1_1() { return cParameter_groupParserRuleCall_1_1; }
		
		//FUNCTION parameter_group
		public Group getGroup_2() { return cGroup_2; }
		
		//FUNCTION
		public RuleCall getFUNCTIONTerminalRuleCall_2_0() { return cFUNCTIONTerminalRuleCall_2_0; }
		
		//parameter_group
		public RuleCall getParameter_groupParserRuleCall_2_1() { return cParameter_groupParserRuleCall_2_1; }
		
		//PROCEDURE parameter_group
		public Group getGroup_3() { return cGroup_3; }
		
		//PROCEDURE
		public RuleCall getPROCEDURETerminalRuleCall_3_0() { return cPROCEDURETerminalRuleCall_3_0; }
		
		//parameter_group
		public RuleCall getParameter_groupParserRuleCall_3_1() { return cParameter_groupParserRuleCall_3_1; }
	}
	public class Parameter_groupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.parameter_group");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifier_listParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesType_identifierParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		
		//parameter_group:
		//	identifier_list ":" types+=type_identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//identifier_list ":" types+=type_identifier
		public Group getGroup() { return cGroup; }
		
		//identifier_list
		public RuleCall getIdentifier_listParserRuleCall_0() { return cIdentifier_listParserRuleCall_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//types+=type_identifier
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//type_identifier
		public RuleCall getTypesType_identifierParserRuleCall_2_0() { return cTypesType_identifierParserRuleCall_2_0; }
	}
	public class Result_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.result_type");
		private final RuleCall cType_identifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//result_type:
		//	type_identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//type_identifier
		public RuleCall getType_identifierParserRuleCall() { return cType_identifierParserRuleCall; }
	}
	public class BoolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.bool");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTRUETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFALSETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//bool:
		//	TRUE | FALSE;
		@Override public ParserRule getRule() { return rule; }
		
		//TRUE | FALSE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TRUE
		public RuleCall getTRUETerminalRuleCall_0() { return cTRUETerminalRuleCall_0; }
		
		//FALSE
		public RuleCall getFALSETerminalRuleCall_1() { return cFALSETerminalRuleCall_1; }
	}
	public class SignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.sign");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPLUSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMINUSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//sign:
		//	PLUS
		//	| MINUS;
		@Override public ParserRule getRule() { return rule; }
		
		//PLUS | MINUS
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS
		public RuleCall getPLUSTerminalRuleCall_0() { return cPLUSTerminalRuleCall_0; }
		
		//MINUS
		public RuleCall getMINUSTerminalRuleCall_1() { return cMINUSTerminalRuleCall_1; }
	}
	
	
	private final PascalElements pPascal;
	private final ProgramElements pProgram;
	private final Program_heading_blockElements pProgram_heading_block;
	private final Identifier_listElements pIdentifier_list;
	private final BlockElements pBlock;
	private final Constant_definition_partElements pConstant_definition_part;
	private final Constant_definitionElements pConstant_definition;
	private final ConstantElements pConstant;
	private final Variable_declaration_partElements pVariable_declaration_part;
	private final Variable_declarationElements pVariable_declaration;
	private final Compound_statementElements pCompound_statement;
	private final StatementsElements pStatements;
	private final StatementElements pStatement;
	private final Unlabelled_statementElements pUnlabelled_statement;
	private final LabelElements pLabel;
	private final Simple_statementElements pSimple_statement;
	private final Assignment_statementElements pAssignment_statement;
	private final VariableElements pVariable;
	private final ExpressionElements pExpression;
	private final Simple_expressionElements pSimple_expression;
	private final TermElements pTerm;
	private final Signed_factorElements pSigned_factor;
	private final FactorElements pFactor;
	private final SetElements pSet;
	private final ElementListElements pElementList;
	private final ElementElements pElement;
	private final TypeElements pType;
	private final Simple_typeElements pSimple_type;
	private final Scalar_typeElements pScalar_type;
	private final Subrange_typeElements pSubrange_type;
	private final Type_identifierElements pType_identifier;
	private final String_typeElements pString_type;
	private final Unsigned_constantElements pUnsigned_constant;
	private final Unsigned_numberElements pUnsigned_number;
	private final Constant_chrElements pConstant_chr;
	private final Procedure_statementElements pProcedure_statement;
	private final Parameter_listElements pParameter_list;
	private final Actual_parameterElements pActual_parameter;
	private final Goto_statementElements pGoto_statement;
	private final Structured_statementElements pStructured_statement;
	private final Unsigned_integerElements pUnsigned_integer;
	private final Unsigned_realElements pUnsigned_real;
	private final Additive_operatorElements pAdditive_operator;
	private final Multiplicative_operatorElements pMultiplicative_operator;
	private final Relational_operatorElements pRelational_operator;
	private final Procedure_and_function_declaration_partElements pProcedure_and_function_declaration_part;
	private final Procedure_or_function_declarationElements pProcedure_or_function_declaration;
	private final Procedure_declarationElements pProcedure_declaration;
	private final Type_definitionElements pType_definition;
	private final Procedure_typeElements pProcedure_type;
	private final Function_declarationElements pFunction_declaration;
	private final Function_typeElements pFunction_type;
	private final Formal_parameter_listElements pFormal_parameter_list;
	private final Formal_parameter_sectionElements pFormal_parameter_section;
	private final Parameter_groupElements pParameter_group;
	private final Result_typeElements pResult_type;
	private final BoolElements pBool;
	private final SignElements pSign;
	private final TerminalRule tVAR;
	private final TerminalRule tNIL;
	private final TerminalRule tDOTDOT;
	private final TerminalRule tNOT;
	private final TerminalRule tTRUE;
	private final TerminalRule tFALSE;
	private final TerminalRule tSTAR;
	private final TerminalRule tSLASH;
	private final TerminalRule tDIV;
	private final TerminalRule tMOD;
	private final TerminalRule tPLUS;
	private final TerminalRule tMINUS;
	private final TerminalRule tAND;
	private final TerminalRule tOR;
	private final TerminalRule tASSIGN;
	private final TerminalRule tNUM_INT;
	private final TerminalRule tNUM_REAL;
	private final TerminalRule tEXPONENT;
	private final TerminalRule tEQUAL;
	private final TerminalRule tNOT_EQUAL;
	private final TerminalRule tLT;
	private final TerminalRule tLE;
	private final TerminalRule tGE;
	private final TerminalRule tGT;
	private final TerminalRule tIN;
	private final TerminalRule tPROCEDURE;
	private final TerminalRule tFUNCTION;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public PascalGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pPascal = new PascalElements();
		this.pProgram = new ProgramElements();
		this.pProgram_heading_block = new Program_heading_blockElements();
		this.pIdentifier_list = new Identifier_listElements();
		this.pBlock = new BlockElements();
		this.pConstant_definition_part = new Constant_definition_partElements();
		this.pConstant_definition = new Constant_definitionElements();
		this.pConstant = new ConstantElements();
		this.pVariable_declaration_part = new Variable_declaration_partElements();
		this.pVariable_declaration = new Variable_declarationElements();
		this.pCompound_statement = new Compound_statementElements();
		this.pStatements = new StatementsElements();
		this.pStatement = new StatementElements();
		this.pUnlabelled_statement = new Unlabelled_statementElements();
		this.pLabel = new LabelElements();
		this.pSimple_statement = new Simple_statementElements();
		this.pAssignment_statement = new Assignment_statementElements();
		this.pVariable = new VariableElements();
		this.pExpression = new ExpressionElements();
		this.pSimple_expression = new Simple_expressionElements();
		this.pTerm = new TermElements();
		this.pSigned_factor = new Signed_factorElements();
		this.pFactor = new FactorElements();
		this.pSet = new SetElements();
		this.pElementList = new ElementListElements();
		this.pElement = new ElementElements();
		this.pType = new TypeElements();
		this.pSimple_type = new Simple_typeElements();
		this.pScalar_type = new Scalar_typeElements();
		this.pSubrange_type = new Subrange_typeElements();
		this.pType_identifier = new Type_identifierElements();
		this.pString_type = new String_typeElements();
		this.pUnsigned_constant = new Unsigned_constantElements();
		this.pUnsigned_number = new Unsigned_numberElements();
		this.pConstant_chr = new Constant_chrElements();
		this.pProcedure_statement = new Procedure_statementElements();
		this.pParameter_list = new Parameter_listElements();
		this.pActual_parameter = new Actual_parameterElements();
		this.pGoto_statement = new Goto_statementElements();
		this.pStructured_statement = new Structured_statementElements();
		this.pUnsigned_integer = new Unsigned_integerElements();
		this.pUnsigned_real = new Unsigned_realElements();
		this.pAdditive_operator = new Additive_operatorElements();
		this.pMultiplicative_operator = new Multiplicative_operatorElements();
		this.pRelational_operator = new Relational_operatorElements();
		this.pProcedure_and_function_declaration_part = new Procedure_and_function_declaration_partElements();
		this.pProcedure_or_function_declaration = new Procedure_or_function_declarationElements();
		this.pProcedure_declaration = new Procedure_declarationElements();
		this.pType_definition = new Type_definitionElements();
		this.pProcedure_type = new Procedure_typeElements();
		this.pFunction_declaration = new Function_declarationElements();
		this.pFunction_type = new Function_typeElements();
		this.pFormal_parameter_list = new Formal_parameter_listElements();
		this.pFormal_parameter_section = new Formal_parameter_sectionElements();
		this.pParameter_group = new Parameter_groupElements();
		this.pResult_type = new Result_typeElements();
		this.pBool = new BoolElements();
		this.pSign = new SignElements();
		this.tVAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.VAR");
		this.tNIL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NIL");
		this.tDOTDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.DOTDOT");
		this.tNOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NOT");
		this.tTRUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.TRUE");
		this.tFALSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.FALSE");
		this.tSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.STAR");
		this.tSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.SLASH");
		this.tDIV = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.DIV");
		this.tMOD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.MOD");
		this.tPLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.PLUS");
		this.tMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.MINUS");
		this.tAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.AND");
		this.tOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.OR");
		this.tASSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.ASSIGN");
		this.tNUM_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NUM_INT");
		this.tNUM_REAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NUM_REAL");
		this.tEXPONENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.EXPONENT");
		this.tEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.EQUAL");
		this.tNOT_EQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NOT_EQUAL");
		this.tLT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.LT");
		this.tLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.LE");
		this.tGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.GE");
		this.tGT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.GT");
		this.tIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.IN");
		this.tPROCEDURE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.PROCEDURE");
		this.tFUNCTION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.FUNCTION");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.compiler.pascal.Pascal".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//pascal:
	//	program+=program;
	public PascalElements getPascalAccess() {
		return pPascal;
	}
	
	public ParserRule getPascalRule() {
		return getPascalAccess().getRule();
	}
	
	//program:
	//	heading=program_heading_block block=block ".";
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//program_heading_block:
	//	"program" name=ID ("(" identifiers=identifier_list ")")? ";";
	public Program_heading_blockElements getProgram_heading_blockAccess() {
		return pProgram_heading_block;
	}
	
	public ParserRule getProgram_heading_blockRule() {
		return getProgram_heading_blockAccess().getRule();
	}
	
	//identifier_list:
	//	names+=ID ("," names+=ID)*;
	public Identifier_listElements getIdentifier_listAccess() {
		return pIdentifier_list;
	}
	
	public ParserRule getIdentifier_listRule() {
		return getIdentifier_listAccess().getRule();
	}
	
	//block:
	//	(constantpart+=constant_definition_part | variablepart+=variable_declaration_part |
	//	procedure_function_part+=procedure_and_function_declaration_part)* statement=compound_statement;
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//constant_definition_part:
	//	'const' (constants+=constant_definition ';')+;
	public Constant_definition_partElements getConstant_definition_partAccess() {
		return pConstant_definition_part;
	}
	
	public ParserRule getConstant_definition_partRule() {
		return getConstant_definition_partAccess().getRule();
	}
	
	//constant_definition:
	//	name=ID EQUAL constant;
	public Constant_definitionElements getConstant_definitionAccess() {
		return pConstant_definition;
	}
	
	public ParserRule getConstant_definitionRule() {
		return getConstant_definitionAccess().getRule();
	}
	
	//constant:
	//	unsigned_number
	//	| sign unsigned_number
	//	| names+=ID
	//	| sign names+=ID
	//	| string+=STRING
	//	| constant_chr;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//variable_declaration_part:
	//	VAR variable+=variable_declaration (";" variable+=variable_declaration)* ";";
	public Variable_declaration_partElements getVariable_declaration_partAccess() {
		return pVariable_declaration_part;
	}
	
	public ParserRule getVariable_declaration_partRule() {
		return getVariable_declaration_partAccess().getRule();
	}
	
	//variable_declaration:
	//	identifier_list ":" types+=type;
	public Variable_declarationElements getVariable_declarationAccess() {
		return pVariable_declaration;
	}
	
	public ParserRule getVariable_declarationRule() {
		return getVariable_declarationAccess().getRule();
	}
	
	//compound_statement:
	//	"begin" sequence=statements "end";
	public Compound_statementElements getCompound_statementAccess() {
		return pCompound_statement;
	}
	
	public ParserRule getCompound_statementRule() {
		return getCompound_statementAccess().getRule();
	}
	
	//statements:
	//	statements+=statement (";" statements+=statement)*;
	public StatementsElements getStatementsAccess() {
		return pStatements;
	}
	
	public ParserRule getStatementsRule() {
		return getStatementsAccess().getRule();
	}
	
	//statement:
	//	label=label ":" statement+=unlabelled_statement | {statement} statement+=unlabelled_statement?;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//unlabelled_statement:
	//	simple=simple_statement | structured=structured_statement;
	public Unlabelled_statementElements getUnlabelled_statementAccess() {
		return pUnlabelled_statement;
	}
	
	public ParserRule getUnlabelled_statementRule() {
		return getUnlabelled_statementAccess().getRule();
	}
	
	//label:
	//	number=unsigned_integer;
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}
	
	//simple_statement:
	//	assignment=assignment_statement | procedure=procedure_statement | goto=goto_statement;
	public Simple_statementElements getSimple_statementAccess() {
		return pSimple_statement;
	}
	
	public ParserRule getSimple_statementRule() {
		return getSimple_statementAccess().getRule();
	}
	
	//assignment_statement:
	//	variable=variable ASSIGN expression=expression;
	public Assignment_statementElements getAssignment_statementAccess() {
		return pAssignment_statement;
	}
	
	public ParserRule getAssignment_statementRule() {
		return getAssignment_statementAccess().getRule();
	}
	
	//variable:
	//	('@' names+=ID | names+=ID) ('[' expression+=expression ("," expression+=expression)* ']' | "(."
	//	expression+=expression ("," expression+=expression)* ".)" | "." names+=ID | "^")*;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//expression:
	//	expressions+=simple_expression (operators+=relational_operator expressions+=expression)?;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//simple_expression:
	//	terms+=term (operators+=additive_operator expression+=simple_expression)?;
	public Simple_expressionElements getSimple_expressionAccess() {
		return pSimple_expression;
	}
	
	public ParserRule getSimple_expressionRule() {
		return getSimple_expressionAccess().getRule();
	}
	
	//term:
	//	factors+=signed_factor (operators+=multiplicative_operator terms+=term)?;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//signed_factor:
	//	(operators+=PLUS | operators+=MINUS)? factors+=factor;
	public Signed_factorElements getSigned_factorAccess() {
		return pSigned_factor;
	}
	
	public ParserRule getSigned_factorRule() {
		return getSigned_factorAccess().getRule();
	}
	
	//factor:
	//	variable=variable
	//	| "(" expression=expression ")"
	//	//| functionDesignator
	//	| constant=unsigned_constant
	//	| set=set
	//	| NOT factor=factor
	//	| boolean+=bool;
	public FactorElements getFactorAccess() {
		return pFactor;
	}
	
	public ParserRule getFactorRule() {
		return getFactorAccess().getRule();
	}
	
	//set:
	//	"[" elements+=elementList "]"
	//	| "(." elements+=elementList ".)";
	public SetElements getSetAccess() {
		return pSet;
	}
	
	public ParserRule getSetRule() {
		return getSetAccess().getRule();
	}
	
	//elementList:
	//	elements+=element ("," elements+=element)*;
	public ElementListElements getElementListAccess() {
		return pElementList;
	}
	
	public ParserRule getElementListRule() {
		return getElementListAccess().getRule();
	}
	
	//element:
	//	expressions+=expression (dotdot+=DOTDOT expressions+=expression)?;
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}
	
	//type:
	//	type+=simple_type
	//	//| type+=structured_type
	//	//| type+=pointer_type
	//;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//simple_type:
	//	types+=scalar_type
	//	| types+=subrange_type
	//	| types+=type_identifier
	//	| types+=string_type;
	public Simple_typeElements getSimple_typeAccess() {
		return pSimple_type;
	}
	
	public ParserRule getSimple_typeRule() {
		return getSimple_typeAccess().getRule();
	}
	
	//scalar_type:
	//	"(" identifier_list ")";
	public Scalar_typeElements getScalar_typeAccess() {
		return pScalar_type;
	}
	
	public ParserRule getScalar_typeRule() {
		return getScalar_typeAccess().getRule();
	}
	
	//subrange_type:
	//	constants+=constant DOTDOT constants+=constant;
	public Subrange_typeElements getSubrange_typeAccess() {
		return pSubrange_type;
	}
	
	public ParserRule getSubrange_typeRule() {
		return getSubrange_typeAccess().getRule();
	}
	
	//type_identifier:
	//	names+=ID
	//	| (type+='CHAR' | type+='boolean' | type+='integer' | type+='real' | type+='string');
	public Type_identifierElements getType_identifierAccess() {
		return pType_identifier;
	}
	
	public ParserRule getType_identifierRule() {
		return getType_identifierAccess().getRule();
	}
	
	//string_type:
	//	'string' '[' (names+=ID | number+=unsigned_number) ']';
	public String_typeElements getString_typeAccess() {
		return pString_type;
	}
	
	public ParserRule getString_typeRule() {
		return getString_typeAccess().getRule();
	}
	
	//unsigned_constant:
	//	number+=unsigned_number
	//	| char+=constant_chr
	//	| string+=STRING
	//	| nil+=NIL;
	public Unsigned_constantElements getUnsigned_constantAccess() {
		return pUnsigned_constant;
	}
	
	public ParserRule getUnsigned_constantRule() {
		return getUnsigned_constantAccess().getRule();
	}
	
	//unsigned_number:
	//	numbers+=unsigned_integer
	//	| numbers+=unsigned_real;
	public Unsigned_numberElements getUnsigned_numberAccess() {
		return pUnsigned_number;
	}
	
	public ParserRule getUnsigned_numberRule() {
		return getUnsigned_numberAccess().getRule();
	}
	
	//constant_chr:
	//	"chr" "(" numbers+=unsigned_integer ")";
	public Constant_chrElements getConstant_chrAccess() {
		return pConstant_chr;
	}
	
	public ParserRule getConstant_chrRule() {
		return getConstant_chrAccess().getRule();
	}
	
	//procedure_statement:
	//	names+=ID ('(' types+=parameter_list ')')?;
	public Procedure_statementElements getProcedure_statementAccess() {
		return pProcedure_statement;
	}
	
	public ParserRule getProcedure_statementRule() {
		return getProcedure_statementAccess().getRule();
	}
	
	//parameter_list:
	//	actual_parameter (',' types+=actual_parameter)*;
	public Parameter_listElements getParameter_listAccess() {
		return pParameter_list;
	}
	
	public ParserRule getParameter_listRule() {
		return getParameter_listAccess().getRule();
	}
	
	//actual_parameter:
	//	expression;
	public Actual_parameterElements getActual_parameterAccess() {
		return pActual_parameter;
	}
	
	public ParserRule getActual_parameterRule() {
		return getActual_parameterAccess().getRule();
	}
	
	//goto_statement:
	//	"goto";
	public Goto_statementElements getGoto_statementAccess() {
		return pGoto_statement;
	}
	
	public ParserRule getGoto_statementRule() {
		return getGoto_statementAccess().getRule();
	}
	
	//structured_statement:
	//	"structured";
	public Structured_statementElements getStructured_statementAccess() {
		return pStructured_statement;
	}
	
	public ParserRule getStructured_statementRule() {
		return getStructured_statementAccess().getRule();
	}
	
	//unsigned_integer:
	//	NUM_INT;
	public Unsigned_integerElements getUnsigned_integerAccess() {
		return pUnsigned_integer;
	}
	
	public ParserRule getUnsigned_integerRule() {
		return getUnsigned_integerAccess().getRule();
	}
	
	//unsigned_real:
	//	NUM_REAL;
	public Unsigned_realElements getUnsigned_realAccess() {
		return pUnsigned_real;
	}
	
	public ParserRule getUnsigned_realRule() {
		return getUnsigned_realAccess().getRule();
	}
	
	//additive_operator:
	//	PLUS
	//	| MINUS
	//	| OR;
	public Additive_operatorElements getAdditive_operatorAccess() {
		return pAdditive_operator;
	}
	
	public ParserRule getAdditive_operatorRule() {
		return getAdditive_operatorAccess().getRule();
	}
	
	//multiplicative_operator:
	//	STAR
	//	| SLASH
	//	| DIV
	//	| MOD
	//	| AND;
	public Multiplicative_operatorElements getMultiplicative_operatorAccess() {
		return pMultiplicative_operator;
	}
	
	public ParserRule getMultiplicative_operatorRule() {
		return getMultiplicative_operatorAccess().getRule();
	}
	
	//relational_operator:
	//	EQUAL
	//	| NOT_EQUAL
	//	| LT
	//	| LE
	//	| GE
	//	| GT
	//	| IN;
	public Relational_operatorElements getRelational_operatorAccess() {
		return pRelational_operator;
	}
	
	public ParserRule getRelational_operatorRule() {
		return getRelational_operatorAccess().getRule();
	}
	
	//procedure_and_function_declaration_part:
	//	procedure_or_function_declaration ";";
	public Procedure_and_function_declaration_partElements getProcedure_and_function_declaration_partAccess() {
		return pProcedure_and_function_declaration_part;
	}
	
	public ParserRule getProcedure_and_function_declaration_partRule() {
		return getProcedure_and_function_declaration_partAccess().getRule();
	}
	
	//procedure_or_function_declaration:
	//	procedure_declaration | function_declaration;
	public Procedure_or_function_declarationElements getProcedure_or_function_declarationAccess() {
		return pProcedure_or_function_declaration;
	}
	
	public ParserRule getProcedure_or_function_declarationRule() {
		return getProcedure_or_function_declarationAccess().getRule();
	}
	
	//procedure_declaration:
	//	PROCEDURE names+=ID types+=formal_parameter_list? ';' block=block;
	public Procedure_declarationElements getProcedure_declarationAccess() {
		return pProcedure_declaration;
	}
	
	public ParserRule getProcedure_declarationRule() {
		return getProcedure_declarationAccess().getRule();
	}
	
	//type_definition:
	//	names+=ID EQUAL (type | function_type | procedure_type);
	public Type_definitionElements getType_definitionAccess() {
		return pType_definition;
	}
	
	public ParserRule getType_definitionRule() {
		return getType_definitionAccess().getRule();
	}
	
	//procedure_type:
	//	{procedure_type} PROCEDURE types+=formal_parameter_list?;
	public Procedure_typeElements getProcedure_typeAccess() {
		return pProcedure_type;
	}
	
	public ParserRule getProcedure_typeRule() {
		return getProcedure_typeAccess().getRule();
	}
	
	//function_declaration:
	//	FUNCTION names+=ID types+=formal_parameter_list? ':'
	//	types+=result_type ';' block=block;
	public Function_declarationElements getFunction_declarationAccess() {
		return pFunction_declaration;
	}
	
	public ParserRule getFunction_declarationRule() {
		return getFunction_declarationAccess().getRule();
	}
	
	//function_type:
	//	names+=ID types+=formal_parameter_list? ':' types+=result_type;
	public Function_typeElements getFunction_typeAccess() {
		return pFunction_type;
	}
	
	public ParserRule getFunction_typeRule() {
		return getFunction_typeAccess().getRule();
	}
	
	//formal_parameter_list:
	//	'(' formal_parameter_section (';' types+=formal_parameter_section)* ')';
	public Formal_parameter_listElements getFormal_parameter_listAccess() {
		return pFormal_parameter_list;
	}
	
	public ParserRule getFormal_parameter_listRule() {
		return getFormal_parameter_listAccess().getRule();
	}
	
	//formal_parameter_section:
	//	parameter_group
	//	| VAR parameter_group
	//	| FUNCTION parameter_group
	//	| PROCEDURE parameter_group;
	public Formal_parameter_sectionElements getFormal_parameter_sectionAccess() {
		return pFormal_parameter_section;
	}
	
	public ParserRule getFormal_parameter_sectionRule() {
		return getFormal_parameter_sectionAccess().getRule();
	}
	
	//parameter_group:
	//	identifier_list ":" types+=type_identifier;
	public Parameter_groupElements getParameter_groupAccess() {
		return pParameter_group;
	}
	
	public ParserRule getParameter_groupRule() {
		return getParameter_groupAccess().getRule();
	}
	
	//result_type:
	//	type_identifier;
	public Result_typeElements getResult_typeAccess() {
		return pResult_type;
	}
	
	public ParserRule getResult_typeRule() {
		return getResult_typeAccess().getRule();
	}
	
	//bool:
	//	TRUE | FALSE;
	public BoolElements getBoolAccess() {
		return pBool;
	}
	
	public ParserRule getBoolRule() {
		return getBoolAccess().getRule();
	}
	
	//sign:
	//	PLUS
	//	| MINUS;
	public SignElements getSignAccess() {
		return pSign;
	}
	
	public ParserRule getSignRule() {
		return getSignAccess().getRule();
	}
	
	//terminal VAR:
	//	('V' | 'v') ('A' | 'a') ('R' | 'r');
	public TerminalRule getVARRule() {
		return tVAR;
	}
	
	//terminal NIL:
	//	('N' | 'n') ('I' | 'i') ('L' | 'l');
	public TerminalRule getNILRule() {
		return tNIL;
	}
	
	//terminal DOTDOT:
	//	'..';
	public TerminalRule getDOTDOTRule() {
		return tDOTDOT;
	}
	
	//terminal NOT:
	//	('N' | 'n') ('O' | 'o') ('T' | 't');
	public TerminalRule getNOTRule() {
		return tNOT;
	}
	
	//terminal TRUE:
	//	('T' | 't') ('R' | 'r') ('U' | 'u') ('e' | 'E');
	public TerminalRule getTRUERule() {
		return tTRUE;
	}
	
	//terminal FALSE:
	//	('F' | 'f') ('A' | 'a') ('L' | 'l') ('S' | 's') ('E' | 'e');
	public TerminalRule getFALSERule() {
		return tFALSE;
	}
	
	//terminal STAR:
	//	'*';
	public TerminalRule getSTARRule() {
		return tSTAR;
	}
	
	//terminal SLASH:
	//	'/';
	public TerminalRule getSLASHRule() {
		return tSLASH;
	}
	
	//terminal DIV:
	//	('D' | 'd') ('I' | 'i') ('V' | 'v');
	public TerminalRule getDIVRule() {
		return tDIV;
	}
	
	//terminal MOD:
	//	('M' | 'm') ('O' | 'o') ('D' | 'd');
	public TerminalRule getMODRule() {
		return tMOD;
	}
	
	//terminal PLUS:
	//	'+';
	public TerminalRule getPLUSRule() {
		return tPLUS;
	}
	
	//terminal MINUS:
	//	'-';
	public TerminalRule getMINUSRule() {
		return tMINUS;
	}
	
	//terminal AND:
	//	('A' | 'a') ('N' | 'n') ('D' | 'd');
	public TerminalRule getANDRule() {
		return tAND;
	}
	
	//terminal OR:
	//	('O' | 'o') ('R' | 'r');
	public TerminalRule getORRule() {
		return tOR;
	}
	
	//terminal ASSIGN:
	//	':=';
	public TerminalRule getASSIGNRule() {
		return tASSIGN;
	}
	
	//terminal NUM_INT:
	//	'0'..'9'+;
	public TerminalRule getNUM_INTRule() {
		return tNUM_INT;
	}
	
	//terminal NUM_REAL:
	//	'0'..'9'+ ('.' '0'..'9'+ EXPONENT?? | EXPONENT);
	public TerminalRule getNUM_REALRule() {
		return tNUM_REAL;
	}
	
	//terminal fragment EXPONENT:
	//	'e' (PLUS | MINUS)? '0'..'9'+;
	public TerminalRule getEXPONENTRule() {
		return tEXPONENT;
	}
	
	//terminal EQUAL:
	//	'=';
	public TerminalRule getEQUALRule() {
		return tEQUAL;
	}
	
	//terminal NOT_EQUAL:
	//	'<>';
	public TerminalRule getNOT_EQUALRule() {
		return tNOT_EQUAL;
	}
	
	//terminal LT:
	//	'<';
	public TerminalRule getLTRule() {
		return tLT;
	}
	
	//terminal LE:
	//	'<=';
	public TerminalRule getLERule() {
		return tLE;
	}
	
	//terminal GE:
	//	'>=';
	public TerminalRule getGERule() {
		return tGE;
	}
	
	//terminal GT:
	//	'>';
	public TerminalRule getGTRule() {
		return tGT;
	}
	
	//terminal IN:
	//	('I' | 'i') ('N' | 'n');
	public TerminalRule getINRule() {
		return tIN;
	}
	
	//terminal PROCEDURE:
	//	'procedure';
	public TerminalRule getPROCEDURERule() {
		return tPROCEDURE;
	}
	
	//terminal FUNCTION:
	//	'function';
	public TerminalRule getFUNCTIONRule() {
		return tFUNCTION;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
