/*
 * generated by Xtext 2.15.0
 */
package org.xtext.compiler.pascal.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class PascalGrammarAccess extends AbstractGrammarElementFinder {
	
	public class PascalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.pascal");
		private final Assignment cProgramAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cProgramProgramParserRuleCall_0 = (RuleCall)cProgramAssignment.eContents().get(0);
		
		//pascal:
		//	program=program;
		@Override public ParserRule getRule() { return rule; }
		
		//program=program
		public Assignment getProgramAssignment() { return cProgramAssignment; }
		
		//program
		public RuleCall getProgramProgramParserRuleCall_0() { return cProgramProgramParserRuleCall_0; }
	}
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadingAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadingProgram_heading_blockParserRuleCall_0_0 = (RuleCall)cHeadingAssignment_0.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//program:
		//	heading=program_heading_block block=block ".";
		@Override public ParserRule getRule() { return rule; }
		
		//heading=program_heading_block block=block "."
		public Group getGroup() { return cGroup; }
		
		//heading=program_heading_block
		public Assignment getHeadingAssignment_0() { return cHeadingAssignment_0; }
		
		//program_heading_block
		public RuleCall getHeadingProgram_heading_blockParserRuleCall_0_0() { return cHeadingProgram_heading_blockParserRuleCall_0_0; }
		
		//block=block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }
		
		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}
	public class Program_heading_blockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.program_heading_block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProgramKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//program_heading_block:
		//	"program" name=ID ";";
		@Override public ParserRule getRule() { return rule; }
		
		//"program" name=ID ";"
		public Group getGroup() { return cGroup; }
		
		//"program"
		public Keyword getProgramKeyword_0() { return cProgramKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class Identifier_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.identifier_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIdentifierParserRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNamesIdentifierParserRuleCall_1_1_0 = (RuleCall)cNamesAssignment_1_1.eContents().get(0);
		
		//identifier_list:
		//	names+=identifier ("," names+=identifier)*;
		@Override public ParserRule getRule() { return rule; }
		
		//names+=identifier ("," names+=identifier)*
		public Group getGroup() { return cGroup; }
		
		//names+=identifier
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//identifier
		public RuleCall getNamesIdentifierParserRuleCall_0_0() { return cNamesIdentifierParserRuleCall_0_0; }
		
		//("," names+=identifier)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//names+=identifier
		public Assignment getNamesAssignment_1_1() { return cNamesAssignment_1_1; }
		
		//identifier
		public RuleCall getNamesIdentifierParserRuleCall_1_1_0() { return cNamesIdentifierParserRuleCall_1_1_0; }
	}
	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.identifier");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_0 = (RuleCall)cIdAssignment.eContents().get(0);
		
		//identifier:
		//	id=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//id=ID
		public Assignment getIdAssignment() { return cIdAssignment; }
		
		//ID
		public RuleCall getIdIDTerminalRuleCall_0() { return cIdIDTerminalRuleCall_0; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cConstantpartAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cConstantpartConstant_definition_partParserRuleCall_0_0_0 = (RuleCall)cConstantpartAssignment_0_0.eContents().get(0);
		private final Assignment cType_partAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cType_partType_definition_partParserRuleCall_0_1_0 = (RuleCall)cType_partAssignment_0_1.eContents().get(0);
		private final Assignment cVariablepartAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final RuleCall cVariablepartVariable_declaration_partParserRuleCall_0_2_0 = (RuleCall)cVariablepartAssignment_0_2.eContents().get(0);
		private final Assignment cProcedure_function_partAssignment_0_3 = (Assignment)cAlternatives_0.eContents().get(3);
		private final RuleCall cProcedure_function_partProcedure_and_function_declaration_partParserRuleCall_0_3_0 = (RuleCall)cProcedure_function_partAssignment_0_3.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementCompound_statementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		
		//block:
		//	(constantpart+=constant_definition_part | type_part+=type_definition_part | variablepart+=variable_declaration_part |
		//	procedure_function_part+=procedure_and_function_declaration_part)* statement=compound_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//(constantpart+=constant_definition_part | type_part+=type_definition_part | variablepart+=variable_declaration_part |
		//procedure_function_part+=procedure_and_function_declaration_part)* statement=compound_statement
		public Group getGroup() { return cGroup; }
		
		//(constantpart+=constant_definition_part | type_part+=type_definition_part | variablepart+=variable_declaration_part |
		//procedure_function_part+=procedure_and_function_declaration_part)*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//constantpart+=constant_definition_part
		public Assignment getConstantpartAssignment_0_0() { return cConstantpartAssignment_0_0; }
		
		//constant_definition_part
		public RuleCall getConstantpartConstant_definition_partParserRuleCall_0_0_0() { return cConstantpartConstant_definition_partParserRuleCall_0_0_0; }
		
		//type_part+=type_definition_part
		public Assignment getType_partAssignment_0_1() { return cType_partAssignment_0_1; }
		
		//type_definition_part
		public RuleCall getType_partType_definition_partParserRuleCall_0_1_0() { return cType_partType_definition_partParserRuleCall_0_1_0; }
		
		//variablepart+=variable_declaration_part
		public Assignment getVariablepartAssignment_0_2() { return cVariablepartAssignment_0_2; }
		
		//variable_declaration_part
		public RuleCall getVariablepartVariable_declaration_partParserRuleCall_0_2_0() { return cVariablepartVariable_declaration_partParserRuleCall_0_2_0; }
		
		//procedure_function_part+=procedure_and_function_declaration_part
		public Assignment getProcedure_function_partAssignment_0_3() { return cProcedure_function_partAssignment_0_3; }
		
		//procedure_and_function_declaration_part
		public RuleCall getProcedure_function_partProcedure_and_function_declaration_partParserRuleCall_0_3_0() { return cProcedure_function_partProcedure_and_function_declaration_partParserRuleCall_0_3_0; }
		
		//statement=compound_statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }
		
		//compound_statement
		public RuleCall getStatementCompound_statementParserRuleCall_1_0() { return cStatementCompound_statementParserRuleCall_1_0; }
	}
	public class Constant_definition_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.constant_definition_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cConstantsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cConstantsConstant_definitionParserRuleCall_1_0_0 = (RuleCall)cConstantsAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//constant_definition_part:
		//	'const' (constants+=constant_definition ';')+;
		@Override public ParserRule getRule() { return rule; }
		
		//'const' (constants+=constant_definition ';')+
		public Group getGroup() { return cGroup; }
		
		//'const'
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }
		
		//(constants+=constant_definition ';')+
		public Group getGroup_1() { return cGroup_1; }
		
		//constants+=constant_definition
		public Assignment getConstantsAssignment_1_0() { return cConstantsAssignment_1_0; }
		
		//constant_definition
		public RuleCall getConstantsConstant_definitionParserRuleCall_1_0_0() { return cConstantsConstant_definitionParserRuleCall_1_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}
	public class Constant_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.constant_definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cEQUALTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//constant_definition:
		//	name=ID EQUAL constant;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID EQUAL constant
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//EQUAL
		public RuleCall getEQUALTerminalRuleCall_1() { return cEQUALTerminalRuleCall_1; }
		
		//constant
		public RuleCall getConstantParserRuleCall_2() { return cConstantParserRuleCall_2; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cUns_numberAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cUns_numberUnsigned_numberParserRuleCall_0_0 = (RuleCall)cUns_numberAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cSignParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cSig_numberAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSig_numberUnsigned_numberParserRuleCall_1_1_0 = (RuleCall)cSig_numberAssignment_1_1.eContents().get(0);
		private final Assignment cName_idAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cName_idIDTerminalRuleCall_2_0 = (RuleCall)cName_idAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cSignParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cSig_name_idAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cSig_name_idIDTerminalRuleCall_3_1_0 = (RuleCall)cSig_name_idAssignment_3_1.eContents().get(0);
		private final Assignment cStringAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cStringSTRINGTerminalRuleCall_4_0 = (RuleCall)cStringAssignment_4.eContents().get(0);
		private final Assignment cBooltypeAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cBooltypeBoolParserRuleCall_5_0 = (RuleCall)cBooltypeAssignment_5.eContents().get(0);
		
		//constant:
		//	uns_number=unsigned_number
		//	| sign sig_number=unsigned_number
		//	| name_id=ID
		//	| sign sig_name_id=ID
		//	| string=STRING
		//	| booltype=bool;
		@Override public ParserRule getRule() { return rule; }
		
		//uns_number=unsigned_number | sign sig_number=unsigned_number | name_id=ID | sign sig_name_id=ID | string=STRING |
		//booltype=bool
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//uns_number=unsigned_number
		public Assignment getUns_numberAssignment_0() { return cUns_numberAssignment_0; }
		
		//unsigned_number
		public RuleCall getUns_numberUnsigned_numberParserRuleCall_0_0() { return cUns_numberUnsigned_numberParserRuleCall_0_0; }
		
		//sign sig_number=unsigned_number
		public Group getGroup_1() { return cGroup_1; }
		
		//sign
		public RuleCall getSignParserRuleCall_1_0() { return cSignParserRuleCall_1_0; }
		
		//sig_number=unsigned_number
		public Assignment getSig_numberAssignment_1_1() { return cSig_numberAssignment_1_1; }
		
		//unsigned_number
		public RuleCall getSig_numberUnsigned_numberParserRuleCall_1_1_0() { return cSig_numberUnsigned_numberParserRuleCall_1_1_0; }
		
		//name_id=ID
		public Assignment getName_idAssignment_2() { return cName_idAssignment_2; }
		
		//ID
		public RuleCall getName_idIDTerminalRuleCall_2_0() { return cName_idIDTerminalRuleCall_2_0; }
		
		//sign sig_name_id=ID
		public Group getGroup_3() { return cGroup_3; }
		
		//sign
		public RuleCall getSignParserRuleCall_3_0() { return cSignParserRuleCall_3_0; }
		
		//sig_name_id=ID
		public Assignment getSig_name_idAssignment_3_1() { return cSig_name_idAssignment_3_1; }
		
		//ID
		public RuleCall getSig_name_idIDTerminalRuleCall_3_1_0() { return cSig_name_idIDTerminalRuleCall_3_1_0; }
		
		//string=STRING
		public Assignment getStringAssignment_4() { return cStringAssignment_4; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_4_0() { return cStringSTRINGTerminalRuleCall_4_0; }
		
		//booltype=bool
		public Assignment getBooltypeAssignment_5() { return cBooltypeAssignment_5; }
		
		//bool
		public RuleCall getBooltypeBoolParserRuleCall_5_0() { return cBooltypeBoolParserRuleCall_5_0; }
	}
	public class Type_definition_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type_definition_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTypesType_definitionParserRuleCall_1_0_0 = (RuleCall)cTypesAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//type_definition_part:
		//	"type" (types+=type_definition ";")+;
		@Override public ParserRule getRule() { return rule; }
		
		//"type" (types+=type_definition ";")+
		public Group getGroup() { return cGroup; }
		
		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }
		
		//(types+=type_definition ";")+
		public Group getGroup_1() { return cGroup_1; }
		
		//types+=type_definition
		public Assignment getTypesAssignment_1_0() { return cTypesAssignment_1_0; }
		
		//type_definition
		public RuleCall getTypesType_definitionParserRuleCall_1_0_0() { return cTypesType_definitionParserRuleCall_1_0_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}
	public class Type_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type_definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cEQUALTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//type_definition:
		//	name=ID EQUAL type=type;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID EQUAL type=type
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//EQUAL
		public RuleCall getEQUALTerminalRuleCall_1() { return cEQUALTerminalRuleCall_1; }
		
		//type=type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class Variable_declaration_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.variable_declaration_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableVariable_declarationParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariableAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariableVariable_declarationParserRuleCall_2_1_0 = (RuleCall)cVariableAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//variable_declaration_part:
		//	"var" variable+=variable_declaration (";" variable+=variable_declaration)* ";";
		@Override public ParserRule getRule() { return rule; }
		
		//"var" variable+=variable_declaration (";" variable+=variable_declaration)* ";"
		public Group getGroup() { return cGroup; }
		
		//"var"
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//variable+=variable_declaration
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//variable_declaration
		public RuleCall getVariableVariable_declarationParserRuleCall_1_0() { return cVariableVariable_declarationParserRuleCall_1_0; }
		
		//(";" variable+=variable_declaration)*
		public Group getGroup_2() { return cGroup_2; }
		
		//";"
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//variable+=variable_declaration
		public Assignment getVariableAssignment_2_1() { return cVariableAssignment_2_1; }
		
		//variable_declaration
		public RuleCall getVariableVariable_declarationParserRuleCall_2_1_0() { return cVariableVariable_declarationParserRuleCall_2_1_0; }
		
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class Variable_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.variable_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cList_namesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cList_namesIdentifier_listParserRuleCall_0_0 = (RuleCall)cList_namesAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cType_variableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cType_variableTypeParserRuleCall_2_0 = (RuleCall)cType_variableAssignment_2.eContents().get(0);
		
		//variable_declaration:
		//	list_names=identifier_list ":" type_variable=type;
		@Override public ParserRule getRule() { return rule; }
		
		//list_names=identifier_list ":" type_variable=type
		public Group getGroup() { return cGroup; }
		
		//list_names=identifier_list
		public Assignment getList_namesAssignment_0() { return cList_namesAssignment_0; }
		
		//identifier_list
		public RuleCall getList_namesIdentifier_listParserRuleCall_0_0() { return cList_namesIdentifier_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type_variable=type
		public Assignment getType_variableAssignment_2() { return cType_variableAssignment_2; }
		
		//type
		public RuleCall getType_variableTypeParserRuleCall_2_0() { return cType_variableTypeParserRuleCall_2_0; }
	}
	public class Compound_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.compound_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBeginKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSequenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSequenceStatementsParserRuleCall_1_0 = (RuleCall)cSequenceAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//compound_statement:
		//	"begin" sequence=statements "end";
		@Override public ParserRule getRule() { return rule; }
		
		//"begin" sequence=statements "end"
		public Group getGroup() { return cGroup; }
		
		//"begin"
		public Keyword getBeginKeyword_0() { return cBeginKeyword_0; }
		
		//sequence=statements
		public Assignment getSequenceAssignment_1() { return cSequenceAssignment_1; }
		
		//statements
		public RuleCall getSequenceStatementsParserRuleCall_1_0() { return cSequenceStatementsParserRuleCall_1_0; }
		
		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}
	public class StatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.statements");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatementsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_0_0 = (RuleCall)cStatementsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_1_1_0 = (RuleCall)cStatementsAssignment_1_1.eContents().get(0);
		
		//statements:
		//	statements+=statement (";" statements+=statement)*;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=statement (";" statements+=statement)*
		public Group getGroup() { return cGroup; }
		
		//statements+=statement
		public Assignment getStatementsAssignment_0() { return cStatementsAssignment_0; }
		
		//statement
		public RuleCall getStatementsStatementParserRuleCall_0_0() { return cStatementsStatementParserRuleCall_0_0; }
		
		//(";" statements+=statement)*
		public Group getGroup_1() { return cGroup_1; }
		
		//";"
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }
		
		//statements+=statement
		public Assignment getStatementsAssignment_1_1() { return cStatementsAssignment_1_1; }
		
		//statement
		public RuleCall getStatementsStatementParserRuleCall_1_1_0() { return cStatementsStatementParserRuleCall_1_1_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementUnlabelled_statementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		
		//statement:
		//	{statement} statement+=unlabelled_statement?;
		@Override public ParserRule getRule() { return rule; }
		
		//{statement} statement+=unlabelled_statement?
		public Group getGroup() { return cGroup; }
		
		//{statement}
		public Action getStatementAction_0() { return cStatementAction_0; }
		
		//statement+=unlabelled_statement?
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }
		
		//unlabelled_statement
		public RuleCall getStatementUnlabelled_statementParserRuleCall_1_0() { return cStatementUnlabelled_statementParserRuleCall_1_0; }
	}
	public class Unlabelled_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unlabelled_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cSimpleAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleSimple_statementParserRuleCall_0_0 = (RuleCall)cSimpleAssignment_0.eContents().get(0);
		private final Assignment cStructuredAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStructuredStructured_statementParserRuleCall_1_0 = (RuleCall)cStructuredAssignment_1.eContents().get(0);
		
		//unlabelled_statement:
		//	simple=simple_statement | structured=structured_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//simple=simple_statement | structured=structured_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//simple=simple_statement
		public Assignment getSimpleAssignment_0() { return cSimpleAssignment_0; }
		
		//simple_statement
		public RuleCall getSimpleSimple_statementParserRuleCall_0_0() { return cSimpleSimple_statementParserRuleCall_0_0; }
		
		//structured=structured_statement
		public Assignment getStructuredAssignment_1() { return cStructuredAssignment_1; }
		
		//structured_statement
		public RuleCall getStructuredStructured_statementParserRuleCall_1_0() { return cStructuredStructured_statementParserRuleCall_1_0; }
	}
	public class Simple_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.simple_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAssignmentAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentAssignment_statementParserRuleCall_0_0 = (RuleCall)cAssignmentAssignment_0.eContents().get(0);
		private final Assignment cProcedureAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cProcedureProcedure_statementParserRuleCall_1_0 = (RuleCall)cProcedureAssignment_1.eContents().get(0);
		
		//simple_statement:
		//	assignment=assignment_statement | procedure=procedure_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//assignment=assignment_statement | procedure=procedure_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//assignment=assignment_statement
		public Assignment getAssignmentAssignment_0() { return cAssignmentAssignment_0; }
		
		//assignment_statement
		public RuleCall getAssignmentAssignment_statementParserRuleCall_0_0() { return cAssignmentAssignment_statementParserRuleCall_0_0; }
		
		//procedure=procedure_statement
		public Assignment getProcedureAssignment_1() { return cProcedureAssignment_1; }
		
		//procedure_statement
		public RuleCall getProcedureProcedure_statementParserRuleCall_1_0() { return cProcedureProcedure_statementParserRuleCall_1_0; }
	}
	public class Assignment_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.assignment_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeclared_variableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeclared_variableVariableParserRuleCall_0_0 = (RuleCall)cDeclared_variableAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//assignment_statement:
		//	declared_variable=variable ASSIGN expression=expression;
		@Override public ParserRule getRule() { return rule; }
		
		//declared_variable=variable ASSIGN expression=expression
		public Group getGroup() { return cGroup; }
		
		//declared_variable=variable
		public Assignment getDeclared_variableAssignment_0() { return cDeclared_variableAssignment_0; }
		
		//variable
		public RuleCall getDeclared_variableVariableParserRuleCall_0_0() { return cDeclared_variableVariableParserRuleCall_0_0; }
		
		//ASSIGN
		public RuleCall getASSIGNTerminalRuleCall_1() { return cASSIGNTerminalRuleCall_1; }
		
		//expression=expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cCommercialAtKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cVariable_idAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cVariable_idIDTerminalRuleCall_0_0_1_0 = (RuleCall)cVariable_idAssignment_0_0_1.eContents().get(0);
		private final Assignment cVariable_idAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cVariable_idIDTerminalRuleCall_0_1_0 = (RuleCall)cVariable_idAssignment_0_1.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cIndiceAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cIndiceExpressionParserRuleCall_1_0_1_0 = (RuleCall)cIndiceAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_0_2 = (Group)cGroup_1_0.eContents().get(2);
		private final Keyword cCommaKeyword_1_0_2_0 = (Keyword)cGroup_1_0_2.eContents().get(0);
		private final Assignment cIndiceAssignment_1_0_2_1 = (Assignment)cGroup_1_0_2.eContents().get(1);
		private final RuleCall cIndiceExpressionParserRuleCall_1_0_2_1_0 = (RuleCall)cIndiceAssignment_1_0_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftParenthesisFullStopKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpressionAssignment_1_1_1.eContents().get(0);
		private final Group cGroup_1_1_2 = (Group)cGroup_1_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_1_2_0 = (Keyword)cGroup_1_1_2.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_2_1 = (Assignment)cGroup_1_1_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_2_1_0 = (RuleCall)cExpressionAssignment_1_1_2_1.eContents().get(0);
		private final Keyword cFullStopRightParenthesisKeyword_1_1_3 = (Keyword)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Keyword cFullStopKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cNames_expAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cNames_expIDTerminalRuleCall_1_2_1_0 = (RuleCall)cNames_expAssignment_1_2_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		
		//variable:
		//	('@' variable_id=ID | variable_id=ID) ('[' indice+=expression ("," indice+=expression)* ']' | "(."
		//	expression+=expression ("," expression+=expression)* ".)" | "." names_exp+=ID | "^")*;
		@Override public ParserRule getRule() { return rule; }
		
		//('@' variable_id=ID | variable_id=ID) ('[' indice+=expression ("," indice+=expression)* ']' | "(."
		//expression+=expression ("," expression+=expression)* ".)" | "." names_exp+=ID | "^")*
		public Group getGroup() { return cGroup; }
		
		//'@' variable_id=ID | variable_id=ID
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'@' variable_id=ID
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0_0_0() { return cCommercialAtKeyword_0_0_0; }
		
		//variable_id=ID
		public Assignment getVariable_idAssignment_0_0_1() { return cVariable_idAssignment_0_0_1; }
		
		//ID
		public RuleCall getVariable_idIDTerminalRuleCall_0_0_1_0() { return cVariable_idIDTerminalRuleCall_0_0_1_0; }
		
		//variable_id=ID
		public Assignment getVariable_idAssignment_0_1() { return cVariable_idAssignment_0_1; }
		
		//ID
		public RuleCall getVariable_idIDTerminalRuleCall_0_1_0() { return cVariable_idIDTerminalRuleCall_0_1_0; }
		
		//('[' indice+=expression ("," indice+=expression)* ']' | "(." expression+=expression ("," expression+=expression)* ".)" |
		//"." names_exp+=ID | "^")*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'[' indice+=expression ("," indice+=expression)* ']'
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0_0() { return cLeftSquareBracketKeyword_1_0_0; }
		
		//indice+=expression
		public Assignment getIndiceAssignment_1_0_1() { return cIndiceAssignment_1_0_1; }
		
		//expression
		public RuleCall getIndiceExpressionParserRuleCall_1_0_1_0() { return cIndiceExpressionParserRuleCall_1_0_1_0; }
		
		//("," indice+=expression)*
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//","
		public Keyword getCommaKeyword_1_0_2_0() { return cCommaKeyword_1_0_2_0; }
		
		//indice+=expression
		public Assignment getIndiceAssignment_1_0_2_1() { return cIndiceAssignment_1_0_2_1; }
		
		//expression
		public RuleCall getIndiceExpressionParserRuleCall_1_0_2_1_0() { return cIndiceExpressionParserRuleCall_1_0_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_0_3() { return cRightSquareBracketKeyword_1_0_3; }
		
		//"(." expression+=expression ("," expression+=expression)* ".)"
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//"(."
		public Keyword getLeftParenthesisFullStopKeyword_1_1_0() { return cLeftParenthesisFullStopKeyword_1_1_0; }
		
		//expression+=expression
		public Assignment getExpressionAssignment_1_1_1() { return cExpressionAssignment_1_1_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_1_0; }
		
		//("," expression+=expression)*
		public Group getGroup_1_1_2() { return cGroup_1_1_2; }
		
		//","
		public Keyword getCommaKeyword_1_1_2_0() { return cCommaKeyword_1_1_2_0; }
		
		//expression+=expression
		public Assignment getExpressionAssignment_1_1_2_1() { return cExpressionAssignment_1_1_2_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_2_1_0() { return cExpressionExpressionParserRuleCall_1_1_2_1_0; }
		
		//".)"
		public Keyword getFullStopRightParenthesisKeyword_1_1_3() { return cFullStopRightParenthesisKeyword_1_1_3; }
		
		//"." names_exp+=ID
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//"."
		public Keyword getFullStopKeyword_1_2_0() { return cFullStopKeyword_1_2_0; }
		
		//names_exp+=ID
		public Assignment getNames_expAssignment_1_2_1() { return cNames_expAssignment_1_2_1; }
		
		//ID
		public RuleCall getNames_expIDTerminalRuleCall_1_2_1_0() { return cNames_expIDTerminalRuleCall_1_2_1_0; }
		
		//"^"
		public Keyword getCircumflexAccentKeyword_1_3() { return cCircumflexAccentKeyword_1_3; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.expression");
		private final Assignment cSimpleAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSimpleSimple_expressionParserRuleCall_0 = (RuleCall)cSimpleAssignment.eContents().get(0);
		
		//expression:
		//	simple=simple_expression;
		@Override public ParserRule getRule() { return rule; }
		
		//simple=simple_expression
		public Assignment getSimpleAssignment() { return cSimpleAssignment; }
		
		//simple_expression
		public RuleCall getSimpleSimple_expressionParserRuleCall_0() { return cSimpleSimple_expressionParserRuleCall_0; }
	}
	public class Simple_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.simple_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTerm_expAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTerm_expTermParserRuleCall_0_0 = (RuleCall)cTerm_expAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorAdditive_operatorParserRuleCall_1_0_0 = (RuleCall)cOperatorAssignment_1_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionSimple_expressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		
		//simple_expression:
		//	term_exp=term (operator=additive_operator expression=simple_expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//term_exp=term (operator=additive_operator expression=simple_expression)?
		public Group getGroup() { return cGroup; }
		
		//term_exp=term
		public Assignment getTerm_expAssignment_0() { return cTerm_expAssignment_0; }
		
		//term
		public RuleCall getTerm_expTermParserRuleCall_0_0() { return cTerm_expTermParserRuleCall_0_0; }
		
		//(operator=additive_operator expression=simple_expression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//operator=additive_operator
		public Assignment getOperatorAssignment_1_0() { return cOperatorAssignment_1_0; }
		
		//additive_operator
		public RuleCall getOperatorAdditive_operatorParserRuleCall_1_0_0() { return cOperatorAdditive_operatorParserRuleCall_1_0_0; }
		
		//expression=simple_expression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }
		
		//simple_expression
		public RuleCall getExpressionSimple_expressionParserRuleCall_1_1_0() { return cExpressionSimple_expressionParserRuleCall_1_1_0; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFactorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFactorSigned_factorParserRuleCall_0_0 = (RuleCall)cFactorAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorMultiplicative_operatorParserRuleCall_1_0_0 = (RuleCall)cOperatorAssignment_1_0.eContents().get(0);
		private final Assignment cTerm2Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTerm2TermParserRuleCall_1_1_0 = (RuleCall)cTerm2Assignment_1_1.eContents().get(0);
		
		//term:
		//	factor=signed_factor (operator=multiplicative_operator term2=term)?;
		@Override public ParserRule getRule() { return rule; }
		
		//factor=signed_factor (operator=multiplicative_operator term2=term)?
		public Group getGroup() { return cGroup; }
		
		//factor=signed_factor
		public Assignment getFactorAssignment_0() { return cFactorAssignment_0; }
		
		//signed_factor
		public RuleCall getFactorSigned_factorParserRuleCall_0_0() { return cFactorSigned_factorParserRuleCall_0_0; }
		
		//(operator=multiplicative_operator term2=term)?
		public Group getGroup_1() { return cGroup_1; }
		
		//operator=multiplicative_operator
		public Assignment getOperatorAssignment_1_0() { return cOperatorAssignment_1_0; }
		
		//multiplicative_operator
		public RuleCall getOperatorMultiplicative_operatorParserRuleCall_1_0_0() { return cOperatorMultiplicative_operatorParserRuleCall_1_0_0; }
		
		//term2=term
		public Assignment getTerm2Assignment_1_1() { return cTerm2Assignment_1_1; }
		
		//term
		public RuleCall getTerm2TermParserRuleCall_1_1_0() { return cTerm2TermParserRuleCall_1_1_0; }
	}
	public class Signed_factorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.signed_factor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cSignalAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cSignalPLUSTerminalRuleCall_0_0_0 = (RuleCall)cSignalAssignment_0_0.eContents().get(0);
		private final Assignment cSignalAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cSignalMINUSTerminalRuleCall_0_1_0 = (RuleCall)cSignalAssignment_0_1.eContents().get(0);
		private final Assignment cFactorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFactorFactorParserRuleCall_1_0 = (RuleCall)cFactorAssignment_1.eContents().get(0);
		
		//signed_factor:
		//	(signal=PLUS | signal=MINUS)? factor=factor;
		@Override public ParserRule getRule() { return rule; }
		
		//(signal=PLUS | signal=MINUS)? factor=factor
		public Group getGroup() { return cGroup; }
		
		//(signal=PLUS | signal=MINUS)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//signal=PLUS
		public Assignment getSignalAssignment_0_0() { return cSignalAssignment_0_0; }
		
		//PLUS
		public RuleCall getSignalPLUSTerminalRuleCall_0_0_0() { return cSignalPLUSTerminalRuleCall_0_0_0; }
		
		//signal=MINUS
		public Assignment getSignalAssignment_0_1() { return cSignalAssignment_0_1; }
		
		//MINUS
		public RuleCall getSignalMINUSTerminalRuleCall_0_1_0() { return cSignalMINUSTerminalRuleCall_0_1_0; }
		
		//factor=factor
		public Assignment getFactorAssignment_1() { return cFactorAssignment_1; }
		
		//factor
		public RuleCall getFactorFactorParserRuleCall_1_0() { return cFactorFactorParserRuleCall_1_0; }
	}
	public class FactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.factor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cFunctionAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cFunctionFunction_designatorParserRuleCall_2_0 = (RuleCall)cFunctionAssignment_2.eContents().get(0);
		private final Assignment cConstantAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cConstantUnsigned_constantParserRuleCall_3_0 = (RuleCall)cConstantAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cNOTTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cNot_factorAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cNot_factorFactorParserRuleCall_4_1_0 = (RuleCall)cNot_factorAssignment_4_1.eContents().get(0);
		private final Assignment cBool_factorAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cBool_factorBoolParserRuleCall_5_0 = (RuleCall)cBool_factorAssignment_5.eContents().get(0);
		
		//factor:
		//	variable=variable
		//	| "(" expression=expression ")"
		//	| function=function_designator
		//	| constant=unsigned_constant
		//	| NOT not_factor=factor
		//	| bool_factor=bool;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=variable | "(" expression=expression ")" | function=function_designator | constant=unsigned_constant | NOT
		//not_factor=factor | bool_factor=bool
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//variable=variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//"(" expression=expression ")"
		public Group getGroup_1() { return cGroup_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//expression=expression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }
		
		//expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//function=function_designator
		public Assignment getFunctionAssignment_2() { return cFunctionAssignment_2; }
		
		//function_designator
		public RuleCall getFunctionFunction_designatorParserRuleCall_2_0() { return cFunctionFunction_designatorParserRuleCall_2_0; }
		
		//constant=unsigned_constant
		public Assignment getConstantAssignment_3() { return cConstantAssignment_3; }
		
		//unsigned_constant
		public RuleCall getConstantUnsigned_constantParserRuleCall_3_0() { return cConstantUnsigned_constantParserRuleCall_3_0; }
		
		//NOT not_factor=factor
		public Group getGroup_4() { return cGroup_4; }
		
		//NOT
		public RuleCall getNOTTerminalRuleCall_4_0() { return cNOTTerminalRuleCall_4_0; }
		
		//not_factor=factor
		public Assignment getNot_factorAssignment_4_1() { return cNot_factorAssignment_4_1; }
		
		//factor
		public RuleCall getNot_factorFactorParserRuleCall_4_1_0() { return cNot_factorFactorParserRuleCall_4_1_0; }
		
		//bool_factor=bool
		public Assignment getBool_factorAssignment_5() { return cBool_factorAssignment_5; }
		
		//bool
		public RuleCall getBool_factorBoolParserRuleCall_5_0() { return cBool_factorBoolParserRuleCall_5_0; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cSimpleAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleSimple_typeParserRuleCall_0_0 = (RuleCall)cSimpleAssignment_0.eContents().get(0);
		private final Assignment cStructuredAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStructuredStructured_typeParserRuleCall_1_0 = (RuleCall)cStructuredAssignment_1.eContents().get(0);
		
		//type:
		//	simple=simple_type
		//	| structured=structured_type;
		@Override public ParserRule getRule() { return rule; }
		
		//simple=simple_type | structured=structured_type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//simple=simple_type
		public Assignment getSimpleAssignment_0() { return cSimpleAssignment_0; }
		
		//simple_type
		public RuleCall getSimpleSimple_typeParserRuleCall_0_0() { return cSimpleSimple_typeParserRuleCall_0_0; }
		
		//structured=structured_type
		public Assignment getStructuredAssignment_1() { return cStructuredAssignment_1; }
		
		//structured_type
		public RuleCall getStructuredStructured_typeParserRuleCall_1_0() { return cStructuredStructured_typeParserRuleCall_1_0; }
	}
	public class Simple_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.simple_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTypeType_identifierParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cSubrange_typeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cSubrange_typeSubrange_typeParserRuleCall_1_0 = (RuleCall)cSubrange_typeAssignment_1.eContents().get(0);
		
		//simple_type:
		//	type=type_identifier
		//	| subrange_type+=subrange_type;
		@Override public ParserRule getRule() { return rule; }
		
		//type=type_identifier | subrange_type+=subrange_type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//type=type_identifier
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//type_identifier
		public RuleCall getTypeType_identifierParserRuleCall_0_0() { return cTypeType_identifierParserRuleCall_0_0; }
		
		//subrange_type+=subrange_type
		public Assignment getSubrange_typeAssignment_1() { return cSubrange_typeAssignment_1; }
		
		//subrange_type
		public RuleCall getSubrange_typeSubrange_typeParserRuleCall_1_0() { return cSubrange_typeSubrange_typeParserRuleCall_1_0; }
	}
	public class Subrange_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.subrange_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantInitAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantInitConstantParserRuleCall_0_0 = (RuleCall)cConstantInitAssignment_0.eContents().get(0);
		private final RuleCall cDOTDOTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cConstantFinalAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConstantFinalConstantParserRuleCall_2_0 = (RuleCall)cConstantFinalAssignment_2.eContents().get(0);
		
		//subrange_type:
		//	constantInit=constant DOTDOT constantFinal=constant;
		@Override public ParserRule getRule() { return rule; }
		
		//constantInit=constant DOTDOT constantFinal=constant
		public Group getGroup() { return cGroup; }
		
		//constantInit=constant
		public Assignment getConstantInitAssignment_0() { return cConstantInitAssignment_0; }
		
		//constant
		public RuleCall getConstantInitConstantParserRuleCall_0_0() { return cConstantInitConstantParserRuleCall_0_0; }
		
		//DOTDOT
		public RuleCall getDOTDOTTerminalRuleCall_1() { return cDOTDOTTerminalRuleCall_1; }
		
		//constantFinal=constant
		public Assignment getConstantFinalAssignment_2() { return cConstantFinalAssignment_2; }
		
		//constant
		public RuleCall getConstantFinalConstantParserRuleCall_2_0() { return cConstantFinalConstantParserRuleCall_2_0; }
	}
	public class Structured_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.structured_type");
		private final Assignment cUnpackedAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cUnpackedUnpacked_structured_typeParserRuleCall_0 = (RuleCall)cUnpackedAssignment.eContents().get(0);
		
		//structured_type:
		//	unpacked=unpacked_structured_type;
		@Override public ParserRule getRule() { return rule; }
		
		////packed = "PACKED" unpacked_structured_type |
		//unpacked=unpacked_structured_type
		public Assignment getUnpackedAssignment() { return cUnpackedAssignment; }
		
		//unpacked_structured_type
		public RuleCall getUnpackedUnpacked_structured_typeParserRuleCall_0() { return cUnpackedUnpacked_structured_typeParserRuleCall_0; }
	}
	public class Unpacked_structured_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unpacked_structured_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cStatic_arrayAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cStatic_arrayArray_typeParserRuleCall_0_0 = (RuleCall)cStatic_arrayAssignment_0.eContents().get(0);
		private final Assignment cDynamicAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDynamicDynamic_array_typeParserRuleCall_1_0 = (RuleCall)cDynamicAssignment_1.eContents().get(0);
		
		//unpacked_structured_type:
		//	static_array=array_type
		//	| dynamic=dynamic_array_type;
		@Override public ParserRule getRule() { return rule; }
		
		//static_array=array_type | dynamic=dynamic_array_type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//static_array=array_type
		public Assignment getStatic_arrayAssignment_0() { return cStatic_arrayAssignment_0; }
		
		//array_type
		public RuleCall getStatic_arrayArray_typeParserRuleCall_0_0() { return cStatic_arrayArray_typeParserRuleCall_0_0; }
		
		//dynamic=dynamic_array_type
		public Assignment getDynamicAssignment_1() { return cDynamicAssignment_1; }
		
		//dynamic_array_type
		public RuleCall getDynamicDynamic_array_typeParserRuleCall_1_0() { return cDynamicDynamic_array_typeParserRuleCall_1_0; }
	}
	public class Dynamic_array_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.dynamic_array_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeType_identifierParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//dynamic_array_type:
		//	"array" "of" type=type_identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//"array" "of" type=type_identifier
		public Group getGroup() { return cGroup; }
		
		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }
		
		//"of"
		public Keyword getOfKeyword_1() { return cOfKeyword_1; }
		
		//type=type_identifier
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//type_identifier
		public RuleCall getTypeType_identifierParserRuleCall_2_0() { return cTypeType_identifierParserRuleCall_2_0; }
	}
	public class Array_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.array_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cArrayKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cType_lAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cType_lType_listParserRuleCall_2_0 = (RuleCall)cType_lAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cOfKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTypeType_identifierParserRuleCall_5_0 = (RuleCall)cTypeAssignment_5.eContents().get(0);
		
		//array_type:
		//	"array" "[" type_l=type_list "]" "of" type=type_identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//"array" "[" type_l=type_list "]" "of" type=type_identifier
		public Group getGroup() { return cGroup; }
		
		//"array"
		public Keyword getArrayKeyword_0() { return cArrayKeyword_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//type_l=type_list
		public Assignment getType_lAssignment_2() { return cType_lAssignment_2; }
		
		//type_list
		public RuleCall getType_lType_listParserRuleCall_2_0() { return cType_lType_listParserRuleCall_2_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
		
		//"of"
		public Keyword getOfKeyword_4() { return cOfKeyword_4; }
		
		//type=type_identifier
		public Assignment getTypeAssignment_5() { return cTypeAssignment_5; }
		
		//type_identifier
		public RuleCall getTypeType_identifierParserRuleCall_5_0() { return cTypeType_identifierParserRuleCall_5_0; }
	}
	public class Type_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIndexesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIndexesIndex_typeParserRuleCall_0_0 = (RuleCall)cIndexesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIndexesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIndexesIndex_typeParserRuleCall_1_1_0 = (RuleCall)cIndexesAssignment_1_1.eContents().get(0);
		
		//type_list:
		//	indexes+=index_type ("," indexes+=index_type)*;
		@Override public ParserRule getRule() { return rule; }
		
		//indexes+=index_type ("," indexes+=index_type)*
		public Group getGroup() { return cGroup; }
		
		//indexes+=index_type
		public Assignment getIndexesAssignment_0() { return cIndexesAssignment_0; }
		
		//index_type
		public RuleCall getIndexesIndex_typeParserRuleCall_0_0() { return cIndexesIndex_typeParserRuleCall_0_0; }
		
		//("," indexes+=index_type)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//indexes+=index_type
		public Assignment getIndexesAssignment_1_1() { return cIndexesAssignment_1_1; }
		
		//index_type
		public RuleCall getIndexesIndex_typeParserRuleCall_1_1_0() { return cIndexesIndex_typeParserRuleCall_1_1_0; }
	}
	public class Index_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.index_type");
		private final Assignment cContentAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cContentSimple_typeParserRuleCall_0 = (RuleCall)cContentAssignment.eContents().get(0);
		
		//index_type:
		//	content=simple_type;
		@Override public ParserRule getRule() { return rule; }
		
		//content=simple_type
		public Assignment getContentAssignment() { return cContentAssignment; }
		
		//simple_type
		public RuleCall getContentSimple_typeParserRuleCall_0() { return cContentSimple_typeParserRuleCall_0; }
	}
	public class Component_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.component_type");
		private final RuleCall cTypeParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//component_type:
		//	type;
		@Override public ParserRule getRule() { return rule; }
		
		//type
		public RuleCall getTypeParserRuleCall() { return cTypeParserRuleCall; }
	}
	public class Type_identifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.type_identifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIdIDTerminalRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cAlternatives.eContents().get(1);
		private final Assignment cBooleanAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cBooleanBooleanKeyword_1_0_0 = (Keyword)cBooleanAssignment_1_0.eContents().get(0);
		private final Assignment cIntegerAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cIntegerIntegerKeyword_1_1_0 = (Keyword)cIntegerAssignment_1_1.eContents().get(0);
		private final Assignment cStringAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final Keyword cStringStringKeyword_1_2_0 = (Keyword)cStringAssignment_1_2.eContents().get(0);
		
		//type_identifier:
		//	id=ID
		//	| (boolean='boolean' | integer='integer' | string='string');
		@Override public ParserRule getRule() { return rule; }
		
		//id=ID | (boolean='boolean' | integer='integer' | string='string')
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//id=ID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }
		
		//ID
		public RuleCall getIdIDTerminalRuleCall_0_0() { return cIdIDTerminalRuleCall_0_0; }
		
		//(boolean='boolean' | integer='integer' | string='string')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//boolean='boolean'
		public Assignment getBooleanAssignment_1_0() { return cBooleanAssignment_1_0; }
		
		//'boolean'
		public Keyword getBooleanBooleanKeyword_1_0_0() { return cBooleanBooleanKeyword_1_0_0; }
		
		//integer='integer'
		public Assignment getIntegerAssignment_1_1() { return cIntegerAssignment_1_1; }
		
		//'integer'
		public Keyword getIntegerIntegerKeyword_1_1_0() { return cIntegerIntegerKeyword_1_1_0; }
		
		//string='string'
		public Assignment getStringAssignment_1_2() { return cStringAssignment_1_2; }
		
		//'string'
		public Keyword getStringStringKeyword_1_2_0() { return cStringStringKeyword_1_2_0; }
	}
	public class Unsigned_constantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unsigned_constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNumberAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNumberUnsigned_numberParserRuleCall_0_0 = (RuleCall)cNumberAssignment_0.eContents().get(0);
		private final Assignment cStringAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cStringSTRINGTerminalRuleCall_1_0 = (RuleCall)cStringAssignment_1.eContents().get(0);
		private final Assignment cNilAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cNilNILTerminalRuleCall_2_0 = (RuleCall)cNilAssignment_2.eContents().get(0);
		
		//unsigned_constant:
		//	number=unsigned_number
		//	| string=STRING
		//	| nil=NIL;
		@Override public ParserRule getRule() { return rule; }
		
		//number=unsigned_number | string=STRING | nil=NIL
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//number=unsigned_number
		public Assignment getNumberAssignment_0() { return cNumberAssignment_0; }
		
		//unsigned_number
		public RuleCall getNumberUnsigned_numberParserRuleCall_0_0() { return cNumberUnsigned_numberParserRuleCall_0_0; }
		
		//string=STRING
		public Assignment getStringAssignment_1() { return cStringAssignment_1; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_1_0() { return cStringSTRINGTerminalRuleCall_1_0; }
		
		//nil=NIL
		public Assignment getNilAssignment_2() { return cNilAssignment_2; }
		
		//NIL
		public RuleCall getNilNILTerminalRuleCall_2_0() { return cNilNILTerminalRuleCall_2_0; }
	}
	public class Unsigned_numberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unsigned_number");
		private final Assignment cNumbersAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNumbersUnsigned_integerParserRuleCall_0 = (RuleCall)cNumbersAssignment.eContents().get(0);
		
		//unsigned_number:
		//	numbers=unsigned_integer;
		@Override public ParserRule getRule() { return rule; }
		
		//numbers=unsigned_integer
		public Assignment getNumbersAssignment() { return cNumbersAssignment; }
		
		//unsigned_integer
		public RuleCall getNumbersUnsigned_integerParserRuleCall_0() { return cNumbersUnsigned_integerParserRuleCall_0; }
	}
	public class Procedure_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cName_idAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cName_idIDTerminalRuleCall_0_0 = (RuleCall)cName_idAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParametersParameter_listParserRuleCall_1_1_0 = (RuleCall)cParametersAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//procedure_statement:
		//	name_id=ID ('(' parameters=parameter_list ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name_id=ID ('(' parameters=parameter_list ')')?
		public Group getGroup() { return cGroup; }
		
		//name_id=ID
		public Assignment getName_idAssignment_0() { return cName_idAssignment_0; }
		
		//ID
		public RuleCall getName_idIDTerminalRuleCall_0_0() { return cName_idIDTerminalRuleCall_0_0; }
		
		//('(' parameters=parameter_list ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//parameters=parameter_list
		public Assignment getParametersAssignment_1_1() { return cParametersAssignment_1_1; }
		
		//parameter_list
		public RuleCall getParametersParameter_listParserRuleCall_1_1_0() { return cParametersParameter_listParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class Parameter_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.parameter_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParametersAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cParametersActual_parameterParserRuleCall_0_0 = (RuleCall)cParametersAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParametersActual_parameterParserRuleCall_1_1_0 = (RuleCall)cParametersAssignment_1_1.eContents().get(0);
		
		//parameter_list:
		//	parameters+=actual_parameter (',' parameters+=actual_parameter)*;
		@Override public ParserRule getRule() { return rule; }
		
		//parameters+=actual_parameter (',' parameters+=actual_parameter)*
		public Group getGroup() { return cGroup; }
		
		//parameters+=actual_parameter
		public Assignment getParametersAssignment_0() { return cParametersAssignment_0; }
		
		//actual_parameter
		public RuleCall getParametersActual_parameterParserRuleCall_0_0() { return cParametersActual_parameterParserRuleCall_0_0; }
		
		//(',' parameters+=actual_parameter)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//parameters+=actual_parameter
		public Assignment getParametersAssignment_1_1() { return cParametersAssignment_1_1; }
		
		//actual_parameter
		public RuleCall getParametersActual_parameterParserRuleCall_1_1_0() { return cParametersActual_parameterParserRuleCall_1_1_0; }
	}
	public class Actual_parameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.actual_parameter");
		private final Assignment cContentAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cContentExpressionParserRuleCall_0 = (RuleCall)cContentAssignment.eContents().get(0);
		
		//actual_parameter:
		//	content=expression;
		@Override public ParserRule getRule() { return rule; }
		
		//content=expression
		public Assignment getContentAssignment() { return cContentAssignment; }
		
		//expression
		public RuleCall getContentExpressionParserRuleCall_0() { return cContentExpressionParserRuleCall_0; }
	}
	public class Structured_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.structured_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cCompound_statAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cCompound_statCompound_statementParserRuleCall_0_0 = (RuleCall)cCompound_statAssignment_0.eContents().get(0);
		private final Assignment cConditional_statAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cConditional_statConditional_statementParserRuleCall_1_0 = (RuleCall)cConditional_statAssignment_1.eContents().get(0);
		
		//structured_statement:
		//	compound_stat=compound_statement
		//	| conditional_stat=conditional_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//compound_stat=compound_statement | conditional_stat=conditional_statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//compound_stat=compound_statement
		public Assignment getCompound_statAssignment_0() { return cCompound_statAssignment_0; }
		
		//compound_statement
		public RuleCall getCompound_statCompound_statementParserRuleCall_0_0() { return cCompound_statCompound_statementParserRuleCall_0_0; }
		
		//conditional_stat=conditional_statement
		public Assignment getConditional_statAssignment_1() { return cConditional_statAssignment_1; }
		
		//conditional_statement
		public RuleCall getConditional_statConditional_statementParserRuleCall_1_0() { return cConditional_statConditional_statementParserRuleCall_1_0; }
	}
	public class Conditional_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.conditional_statement");
		private final Assignment cCond_statementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCond_statementsCase_statementParserRuleCall_0 = (RuleCall)cCond_statementsAssignment.eContents().get(0);
		
		//conditional_statement:
		//	cond_statements=case_statement;
		@Override public ParserRule getRule() { return rule; }
		
		//cond_statements=case_statement
		public Assignment getCond_statementsAssignment() { return cCond_statementsAssignment; }
		
		//case_statement
		public RuleCall getCond_statementsCase_statementParserRuleCall_0() { return cCond_statementsCase_statementParserRuleCall_0; }
	}
	public class Case_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.case_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCase_listAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCase_listCase_list_elementParserRuleCall_3_0 = (RuleCall)cCase_listAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cCase_listAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCase_listCase_list_elementParserRuleCall_4_1_0 = (RuleCall)cCase_listAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cElseKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cCase_statementsAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cCase_statementsStatementsParserRuleCall_6_1_0 = (RuleCall)cCase_statementsAssignment_6_1.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//case_statement:
		//	"case" exp=expression "of" case_list+=case_list_element (";" case_list+=case_list_element)* ";"? ("else"
		//	case_statements=statements)? "end";
		@Override public ParserRule getRule() { return rule; }
		
		//"case" exp=expression "of" case_list+=case_list_element (";" case_list+=case_list_element)* ";"? ("else"
		//case_statements=statements)? "end"
		public Group getGroup() { return cGroup; }
		
		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//exp=expression
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }
		
		//expression
		public RuleCall getExpExpressionParserRuleCall_1_0() { return cExpExpressionParserRuleCall_1_0; }
		
		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }
		
		//case_list+=case_list_element
		public Assignment getCase_listAssignment_3() { return cCase_listAssignment_3; }
		
		//case_list_element
		public RuleCall getCase_listCase_list_elementParserRuleCall_3_0() { return cCase_listCase_list_elementParserRuleCall_3_0; }
		
		//(";" case_list+=case_list_element)*
		public Group getGroup_4() { return cGroup_4; }
		
		//";"
		public Keyword getSemicolonKeyword_4_0() { return cSemicolonKeyword_4_0; }
		
		//case_list+=case_list_element
		public Assignment getCase_listAssignment_4_1() { return cCase_listAssignment_4_1; }
		
		//case_list_element
		public RuleCall getCase_listCase_list_elementParserRuleCall_4_1_0() { return cCase_listCase_list_elementParserRuleCall_4_1_0; }
		
		//";"?
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
		
		//("else" case_statements=statements)?
		public Group getGroup_6() { return cGroup_6; }
		
		//"else"
		public Keyword getElseKeyword_6_0() { return cElseKeyword_6_0; }
		
		//case_statements=statements
		public Assignment getCase_statementsAssignment_6_1() { return cCase_statementsAssignment_6_1; }
		
		//statements
		public RuleCall getCase_statementsStatementsParserRuleCall_6_1_0() { return cCase_statementsStatementsParserRuleCall_6_1_0; }
		
		//"end"
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }
	}
	public class Case_list_elementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.case_list_element");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstsConst_listParserRuleCall_0_0 = (RuleCall)cConstsAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCase_statementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCase_statementStatementParserRuleCall_2_0 = (RuleCall)cCase_statementAssignment_2.eContents().get(0);
		
		//case_list_element:
		//	consts=const_list ":" case_statement=statement;
		@Override public ParserRule getRule() { return rule; }
		
		//consts=const_list ":" case_statement=statement
		public Group getGroup() { return cGroup; }
		
		//consts=const_list
		public Assignment getConstsAssignment_0() { return cConstsAssignment_0; }
		
		//const_list
		public RuleCall getConstsConst_listParserRuleCall_0_0() { return cConstsConst_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//case_statement=statement
		public Assignment getCase_statementAssignment_2() { return cCase_statementAssignment_2; }
		
		//statement
		public RuleCall getCase_statementStatementParserRuleCall_2_0() { return cCase_statementStatementParserRuleCall_2_0; }
	}
	public class Const_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.const_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantsConstantParserRuleCall_0_0 = (RuleCall)cConstantsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConstantsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConstantsConstantParserRuleCall_1_1_0 = (RuleCall)cConstantsAssignment_1_1.eContents().get(0);
		
		//const_list:
		//	constants+=constant ("," constants+=constant)*;
		@Override public ParserRule getRule() { return rule; }
		
		//constants+=constant ("," constants+=constant)*
		public Group getGroup() { return cGroup; }
		
		//constants+=constant
		public Assignment getConstantsAssignment_0() { return cConstantsAssignment_0; }
		
		//constant
		public RuleCall getConstantsConstantParserRuleCall_0_0() { return cConstantsConstantParserRuleCall_0_0; }
		
		//("," constants+=constant)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//constants+=constant
		public Assignment getConstantsAssignment_1_1() { return cConstantsAssignment_1_1; }
		
		//constant
		public RuleCall getConstantsConstantParserRuleCall_1_1_0() { return cConstantsConstantParserRuleCall_1_1_0; }
	}
	public class Unsigned_integerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.unsigned_integer");
		private final RuleCall cNUM_INTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//unsigned_integer:
		//	NUM_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//NUM_INT
		public RuleCall getNUM_INTTerminalRuleCall() { return cNUM_INTTerminalRuleCall; }
	}
	public class Additive_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.additive_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPLUSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMINUSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cORTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//additive_operator:
		//	PLUS
		//	| MINUS
		//	| OR;
		@Override public ParserRule getRule() { return rule; }
		
		//PLUS | MINUS | OR
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS
		public RuleCall getPLUSTerminalRuleCall_0() { return cPLUSTerminalRuleCall_0; }
		
		//MINUS
		public RuleCall getMINUSTerminalRuleCall_1() { return cMINUSTerminalRuleCall_1; }
		
		//OR
		public RuleCall getORTerminalRuleCall_2() { return cORTerminalRuleCall_2; }
	}
	public class Multiplicative_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.multiplicative_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTARTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSLASHTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDIVTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMODTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cANDTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//multiplicative_operator:
		//	STAR
		//	| SLASH
		//	| DIV
		//	| MOD
		//	| AND;
		@Override public ParserRule getRule() { return rule; }
		
		//STAR | SLASH | DIV | MOD | AND
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STAR
		public RuleCall getSTARTerminalRuleCall_0() { return cSTARTerminalRuleCall_0; }
		
		//SLASH
		public RuleCall getSLASHTerminalRuleCall_1() { return cSLASHTerminalRuleCall_1; }
		
		//DIV
		public RuleCall getDIVTerminalRuleCall_2() { return cDIVTerminalRuleCall_2; }
		
		//MOD
		public RuleCall getMODTerminalRuleCall_3() { return cMODTerminalRuleCall_3; }
		
		//AND
		public RuleCall getANDTerminalRuleCall_4() { return cANDTerminalRuleCall_4; }
	}
	public class Procedure_and_function_declaration_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_and_function_declaration_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSubroutineAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSubroutineProcedure_or_function_declarationParserRuleCall_0_0 = (RuleCall)cSubroutineAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//procedure_and_function_declaration_part:
		//	subroutine=procedure_or_function_declaration ";";
		@Override public ParserRule getRule() { return rule; }
		
		//subroutine=procedure_or_function_declaration ";"
		public Group getGroup() { return cGroup; }
		
		//subroutine=procedure_or_function_declaration
		public Assignment getSubroutineAssignment_0() { return cSubroutineAssignment_0; }
		
		//procedure_or_function_declaration
		public RuleCall getSubroutineProcedure_or_function_declarationParserRuleCall_0_0() { return cSubroutineProcedure_or_function_declarationParserRuleCall_0_0; }
		
		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}
	public class Procedure_or_function_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_or_function_declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cProcAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cProcProcedure_declarationParserRuleCall_0_0 = (RuleCall)cProcAssignment_0.eContents().get(0);
		private final Assignment cFuncAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFuncFunction_declarationParserRuleCall_1_0 = (RuleCall)cFuncAssignment_1.eContents().get(0);
		
		//procedure_or_function_declaration:
		//	proc=procedure_declaration | func=function_declaration;
		@Override public ParserRule getRule() { return rule; }
		
		//proc=procedure_declaration | func=function_declaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//proc=procedure_declaration
		public Assignment getProcAssignment_0() { return cProcAssignment_0; }
		
		//procedure_declaration
		public RuleCall getProcProcedure_declarationParserRuleCall_0_0() { return cProcProcedure_declarationParserRuleCall_0_0; }
		
		//func=function_declaration
		public Assignment getFuncAssignment_1() { return cFuncAssignment_1; }
		
		//function_declaration
		public RuleCall getFuncFunction_declarationParserRuleCall_1_0() { return cFuncFunction_declarationParserRuleCall_1_0; }
	}
	public class Procedure_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cProcedureParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNamesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_0 = (RuleCall)cNamesAssignment_1.eContents().get(0);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBlockBlockParserRuleCall_4_0 = (RuleCall)cBlockAssignment_4.eContents().get(0);
		
		//procedure_declaration:
		//	procedure names=ID parameters=formal_parameter_list? ';' block=block;
		@Override public ParserRule getRule() { return rule; }
		
		//procedure names=ID parameters=formal_parameter_list? ';' block=block
		public Group getGroup() { return cGroup; }
		
		//procedure
		public RuleCall getProcedureParserRuleCall_0() { return cProcedureParserRuleCall_0; }
		
		//names=ID
		public Assignment getNamesAssignment_1() { return cNamesAssignment_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_0() { return cNamesIDTerminalRuleCall_1_0; }
		
		//parameters=formal_parameter_list?
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getParametersFormal_parameter_listParserRuleCall_2_0() { return cParametersFormal_parameter_listParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
		
		//block=block
		public Assignment getBlockAssignment_4() { return cBlockAssignment_4; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_4_0() { return cBlockBlockParserRuleCall_4_0; }
	}
	public class Procedure_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProcedure_typeAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cProcedureParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		
		//procedure_type:
		//	{procedure_type} procedure types=formal_parameter_list?;
		@Override public ParserRule getRule() { return rule; }
		
		//{procedure_type} procedure types=formal_parameter_list?
		public Group getGroup() { return cGroup; }
		
		//{procedure_type}
		public Action getProcedure_typeAction_0() { return cProcedure_typeAction_0; }
		
		//procedure
		public RuleCall getProcedureParserRuleCall_1() { return cProcedureParserRuleCall_1; }
		
		//types=formal_parameter_list?
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getTypesFormal_parameter_listParserRuleCall_2_0() { return cTypesFormal_parameter_listParserRuleCall_2_0; }
	}
	public class Function_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.function_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNamesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamesIDTerminalRuleCall_1_0 = (RuleCall)cNamesAssignment_1.eContents().get(0);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersFormal_parameter_listParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypesResult_typeParserRuleCall_4_0 = (RuleCall)cTypesAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBlockAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBlockBlockParserRuleCall_6_0 = (RuleCall)cBlockAssignment_6.eContents().get(0);
		
		//function_declaration:
		//	function names=ID parameters=formal_parameter_list? ':'
		//	types=result_type ';' block=block;
		@Override public ParserRule getRule() { return rule; }
		
		//function names=ID parameters=formal_parameter_list? ':' types=result_type ';' block=block
		public Group getGroup() { return cGroup; }
		
		//function
		public RuleCall getFunctionParserRuleCall_0() { return cFunctionParserRuleCall_0; }
		
		//names=ID
		public Assignment getNamesAssignment_1() { return cNamesAssignment_1; }
		
		//ID
		public RuleCall getNamesIDTerminalRuleCall_1_0() { return cNamesIDTerminalRuleCall_1_0; }
		
		//parameters=formal_parameter_list?
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//formal_parameter_list
		public RuleCall getParametersFormal_parameter_listParserRuleCall_2_0() { return cParametersFormal_parameter_listParserRuleCall_2_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//types=result_type
		public Assignment getTypesAssignment_4() { return cTypesAssignment_4; }
		
		//result_type
		public RuleCall getTypesResult_typeParserRuleCall_4_0() { return cTypesResult_typeParserRuleCall_4_0; }
		
		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
		
		//block=block
		public Assignment getBlockAssignment_6() { return cBlockAssignment_6; }
		
		//block
		public RuleCall getBlockBlockParserRuleCall_6_0() { return cBlockBlockParserRuleCall_6_0; }
	}
	public class Function_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.function_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cParametersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParametersFormal_parameter_listParserRuleCall_1_0 = (RuleCall)cParametersAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypesResult_typeParserRuleCall_3_0 = (RuleCall)cTypesAssignment_3.eContents().get(0);
		
		//function_type:
		//	function parameters=formal_parameter_list? ':' types=result_type;
		@Override public ParserRule getRule() { return rule; }
		
		//function parameters=formal_parameter_list? ':' types=result_type
		public Group getGroup() { return cGroup; }
		
		//function
		public RuleCall getFunctionParserRuleCall_0() { return cFunctionParserRuleCall_0; }
		
		//parameters=formal_parameter_list?
		public Assignment getParametersAssignment_1() { return cParametersAssignment_1; }
		
		//formal_parameter_list
		public RuleCall getParametersFormal_parameter_listParserRuleCall_1_0() { return cParametersFormal_parameter_listParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//types=result_type
		public Assignment getTypesAssignment_3() { return cTypesAssignment_3; }
		
		//result_type
		public RuleCall getTypesResult_typeParserRuleCall_3_0() { return cTypesResult_typeParserRuleCall_3_0; }
	}
	public class Function_designatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.function_designator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cName_functionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cName_functionIDTerminalRuleCall_0_0 = (RuleCall)cName_functionAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersParameter_listParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//function_designator:
		//	name_function=ID '(' parameters=parameter_list ')';
		@Override public ParserRule getRule() { return rule; }
		
		//name_function=ID '(' parameters=parameter_list ')'
		public Group getGroup() { return cGroup; }
		
		//name_function=ID
		public Assignment getName_functionAssignment_0() { return cName_functionAssignment_0; }
		
		//ID
		public RuleCall getName_functionIDTerminalRuleCall_0_0() { return cName_functionIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//parameters=parameter_list
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//parameter_list
		public RuleCall getParametersParameter_listParserRuleCall_2_0() { return cParametersParameter_listParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Formal_parameter_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.formal_parameter_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParametersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParametersFormal_parameter_sectionParserRuleCall_1_0 = (RuleCall)cParametersAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersFormal_parameter_sectionParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//formal_parameter_list:
		//	'(' parameters+=formal_parameter_section (';' parameters+=formal_parameter_section)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' parameters+=formal_parameter_section (';' parameters+=formal_parameter_section)* ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//parameters+=formal_parameter_section
		public Assignment getParametersAssignment_1() { return cParametersAssignment_1; }
		
		//formal_parameter_section
		public RuleCall getParametersFormal_parameter_sectionParserRuleCall_1_0() { return cParametersFormal_parameter_sectionParserRuleCall_1_0; }
		
		//(';' parameters+=formal_parameter_section)*
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//parameters+=formal_parameter_section
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }
		
		//formal_parameter_section
		public RuleCall getParametersFormal_parameter_sectionParserRuleCall_2_1_0() { return cParametersFormal_parameter_sectionParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class Formal_parameter_sectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.formal_parameter_section");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cParametersAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cParametersParameter_groupParserRuleCall_0_0 = (RuleCall)cParametersAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cVarKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParametersParameter_groupParserRuleCall_1_1_0 = (RuleCall)cParametersAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cFunctionParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersParameter_groupParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cProcedureParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cParametersAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParametersParameter_groupParserRuleCall_3_1_0 = (RuleCall)cParametersAssignment_3_1.eContents().get(0);
		
		//formal_parameter_section:
		//	parameters+=parameter_group
		//	| 'var' parameters+=parameter_group
		//	| function parameters+=parameter_group
		//	| procedure parameters+=parameter_group;
		@Override public ParserRule getRule() { return rule; }
		
		//parameters+=parameter_group | 'var' parameters+=parameter_group | function parameters+=parameter_group | procedure
		//parameters+=parameter_group
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//parameters+=parameter_group
		public Assignment getParametersAssignment_0() { return cParametersAssignment_0; }
		
		//parameter_group
		public RuleCall getParametersParameter_groupParserRuleCall_0_0() { return cParametersParameter_groupParserRuleCall_0_0; }
		
		//'var' parameters+=parameter_group
		public Group getGroup_1() { return cGroup_1; }
		
		//'var'
		public Keyword getVarKeyword_1_0() { return cVarKeyword_1_0; }
		
		//parameters+=parameter_group
		public Assignment getParametersAssignment_1_1() { return cParametersAssignment_1_1; }
		
		//parameter_group
		public RuleCall getParametersParameter_groupParserRuleCall_1_1_0() { return cParametersParameter_groupParserRuleCall_1_1_0; }
		
		//function parameters+=parameter_group
		public Group getGroup_2() { return cGroup_2; }
		
		//function
		public RuleCall getFunctionParserRuleCall_2_0() { return cFunctionParserRuleCall_2_0; }
		
		//parameters+=parameter_group
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }
		
		//parameter_group
		public RuleCall getParametersParameter_groupParserRuleCall_2_1_0() { return cParametersParameter_groupParserRuleCall_2_1_0; }
		
		//procedure parameters+=parameter_group
		public Group getGroup_3() { return cGroup_3; }
		
		//procedure
		public RuleCall getProcedureParserRuleCall_3_0() { return cProcedureParserRuleCall_3_0; }
		
		//parameters+=parameter_group
		public Assignment getParametersAssignment_3_1() { return cParametersAssignment_3_1; }
		
		//parameter_group
		public RuleCall getParametersParameter_groupParserRuleCall_3_1_0() { return cParametersParameter_groupParserRuleCall_3_1_0; }
	}
	public class Parameter_groupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.parameter_group");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIdentifier_listParserRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypesType_identifierParserRuleCall_2_0 = (RuleCall)cTypesAssignment_2.eContents().get(0);
		
		//parameter_group:
		//	names=identifier_list ":" types=type_identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//names=identifier_list ":" types=type_identifier
		public Group getGroup() { return cGroup; }
		
		//names=identifier_list
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//identifier_list
		public RuleCall getNamesIdentifier_listParserRuleCall_0_0() { return cNamesIdentifier_listParserRuleCall_0_0; }
		
		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//types=type_identifier
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }
		
		//type_identifier
		public RuleCall getTypesType_identifierParserRuleCall_2_0() { return cTypesType_identifierParserRuleCall_2_0; }
	}
	public class Result_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.result_type");
		private final RuleCall cType_identifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//result_type:
		//	type_identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//type_identifier
		public RuleCall getType_identifierParserRuleCall() { return cType_identifierParserRuleCall; }
	}
	public class BoolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.bool");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//bool:
		//	"true" | "false";
		@Override public ParserRule getRule() { return rule; }
		
		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }
		
		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	public class ProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.procedure");
		private final Keyword cProcedureKeyword = (Keyword)rule.eContents().get(1);
		
		//procedure:
		//	'procedure';
		@Override public ParserRule getRule() { return rule; }
		
		//'procedure'
		public Keyword getProcedureKeyword() { return cProcedureKeyword; }
	}
	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.function");
		private final Keyword cFunctionKeyword = (Keyword)rule.eContents().get(1);
		
		//function:
		//	'function';
		@Override public ParserRule getRule() { return rule; }
		
		//'function'
		public Keyword getFunctionKeyword() { return cFunctionKeyword; }
	}
	public class SignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.sign");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPLUSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMINUSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//sign:
		//	PLUS
		//	| MINUS;
		@Override public ParserRule getRule() { return rule; }
		
		//PLUS | MINUS
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS
		public RuleCall getPLUSTerminalRuleCall_0() { return cPLUSTerminalRuleCall_0; }
		
		//MINUS
		public RuleCall getMINUSTerminalRuleCall_1() { return cMINUSTerminalRuleCall_1; }
	}
	
	
	private final PascalElements pPascal;
	private final ProgramElements pProgram;
	private final Program_heading_blockElements pProgram_heading_block;
	private final Identifier_listElements pIdentifier_list;
	private final IdentifierElements pIdentifier;
	private final BlockElements pBlock;
	private final Constant_definition_partElements pConstant_definition_part;
	private final Constant_definitionElements pConstant_definition;
	private final ConstantElements pConstant;
	private final Type_definition_partElements pType_definition_part;
	private final Type_definitionElements pType_definition;
	private final Variable_declaration_partElements pVariable_declaration_part;
	private final Variable_declarationElements pVariable_declaration;
	private final Compound_statementElements pCompound_statement;
	private final StatementsElements pStatements;
	private final StatementElements pStatement;
	private final Unlabelled_statementElements pUnlabelled_statement;
	private final Simple_statementElements pSimple_statement;
	private final Assignment_statementElements pAssignment_statement;
	private final VariableElements pVariable;
	private final ExpressionElements pExpression;
	private final Simple_expressionElements pSimple_expression;
	private final TermElements pTerm;
	private final Signed_factorElements pSigned_factor;
	private final FactorElements pFactor;
	private final TypeElements pType;
	private final Simple_typeElements pSimple_type;
	private final Subrange_typeElements pSubrange_type;
	private final Structured_typeElements pStructured_type;
	private final Unpacked_structured_typeElements pUnpacked_structured_type;
	private final Dynamic_array_typeElements pDynamic_array_type;
	private final Array_typeElements pArray_type;
	private final Type_listElements pType_list;
	private final Index_typeElements pIndex_type;
	private final Component_typeElements pComponent_type;
	private final Type_identifierElements pType_identifier;
	private final Unsigned_constantElements pUnsigned_constant;
	private final Unsigned_numberElements pUnsigned_number;
	private final Procedure_statementElements pProcedure_statement;
	private final Parameter_listElements pParameter_list;
	private final Actual_parameterElements pActual_parameter;
	private final Structured_statementElements pStructured_statement;
	private final Conditional_statementElements pConditional_statement;
	private final Case_statementElements pCase_statement;
	private final Case_list_elementElements pCase_list_element;
	private final Const_listElements pConst_list;
	private final Unsigned_integerElements pUnsigned_integer;
	private final Additive_operatorElements pAdditive_operator;
	private final Multiplicative_operatorElements pMultiplicative_operator;
	private final Procedure_and_function_declaration_partElements pProcedure_and_function_declaration_part;
	private final Procedure_or_function_declarationElements pProcedure_or_function_declaration;
	private final Procedure_declarationElements pProcedure_declaration;
	private final Procedure_typeElements pProcedure_type;
	private final Function_declarationElements pFunction_declaration;
	private final Function_typeElements pFunction_type;
	private final Function_designatorElements pFunction_designator;
	private final Formal_parameter_listElements pFormal_parameter_list;
	private final Formal_parameter_sectionElements pFormal_parameter_section;
	private final Parameter_groupElements pParameter_group;
	private final Result_typeElements pResult_type;
	private final BoolElements pBool;
	private final ProcedureElements pProcedure;
	private final FunctionElements pFunction;
	private final SignElements pSign;
	private final TerminalRule tNIL;
	private final TerminalRule tDOTDOT;
	private final TerminalRule tNOT;
	private final TerminalRule tSTAR;
	private final TerminalRule tSLASH;
	private final TerminalRule tDIV;
	private final TerminalRule tMOD;
	private final TerminalRule tPLUS;
	private final TerminalRule tMINUS;
	private final TerminalRule tAND;
	private final TerminalRule tOR;
	private final TerminalRule tASSIGN;
	private final TerminalRule tNUM_INT;
	private final TerminalRule tEQUAL;
	private final TerminalRule tID;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public PascalGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pPascal = new PascalElements();
		this.pProgram = new ProgramElements();
		this.pProgram_heading_block = new Program_heading_blockElements();
		this.pIdentifier_list = new Identifier_listElements();
		this.pIdentifier = new IdentifierElements();
		this.pBlock = new BlockElements();
		this.pConstant_definition_part = new Constant_definition_partElements();
		this.pConstant_definition = new Constant_definitionElements();
		this.pConstant = new ConstantElements();
		this.pType_definition_part = new Type_definition_partElements();
		this.pType_definition = new Type_definitionElements();
		this.pVariable_declaration_part = new Variable_declaration_partElements();
		this.pVariable_declaration = new Variable_declarationElements();
		this.pCompound_statement = new Compound_statementElements();
		this.pStatements = new StatementsElements();
		this.pStatement = new StatementElements();
		this.pUnlabelled_statement = new Unlabelled_statementElements();
		this.pSimple_statement = new Simple_statementElements();
		this.pAssignment_statement = new Assignment_statementElements();
		this.pVariable = new VariableElements();
		this.pExpression = new ExpressionElements();
		this.pSimple_expression = new Simple_expressionElements();
		this.pTerm = new TermElements();
		this.pSigned_factor = new Signed_factorElements();
		this.pFactor = new FactorElements();
		this.pType = new TypeElements();
		this.pSimple_type = new Simple_typeElements();
		this.pSubrange_type = new Subrange_typeElements();
		this.pStructured_type = new Structured_typeElements();
		this.pUnpacked_structured_type = new Unpacked_structured_typeElements();
		this.pDynamic_array_type = new Dynamic_array_typeElements();
		this.pArray_type = new Array_typeElements();
		this.pType_list = new Type_listElements();
		this.pIndex_type = new Index_typeElements();
		this.pComponent_type = new Component_typeElements();
		this.pType_identifier = new Type_identifierElements();
		this.pUnsigned_constant = new Unsigned_constantElements();
		this.pUnsigned_number = new Unsigned_numberElements();
		this.pProcedure_statement = new Procedure_statementElements();
		this.pParameter_list = new Parameter_listElements();
		this.pActual_parameter = new Actual_parameterElements();
		this.pStructured_statement = new Structured_statementElements();
		this.pConditional_statement = new Conditional_statementElements();
		this.pCase_statement = new Case_statementElements();
		this.pCase_list_element = new Case_list_elementElements();
		this.pConst_list = new Const_listElements();
		this.pUnsigned_integer = new Unsigned_integerElements();
		this.pAdditive_operator = new Additive_operatorElements();
		this.pMultiplicative_operator = new Multiplicative_operatorElements();
		this.pProcedure_and_function_declaration_part = new Procedure_and_function_declaration_partElements();
		this.pProcedure_or_function_declaration = new Procedure_or_function_declarationElements();
		this.pProcedure_declaration = new Procedure_declarationElements();
		this.pProcedure_type = new Procedure_typeElements();
		this.pFunction_declaration = new Function_declarationElements();
		this.pFunction_type = new Function_typeElements();
		this.pFunction_designator = new Function_designatorElements();
		this.pFormal_parameter_list = new Formal_parameter_listElements();
		this.pFormal_parameter_section = new Formal_parameter_sectionElements();
		this.pParameter_group = new Parameter_groupElements();
		this.pResult_type = new Result_typeElements();
		this.pBool = new BoolElements();
		this.pProcedure = new ProcedureElements();
		this.pFunction = new FunctionElements();
		this.pSign = new SignElements();
		this.tNIL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NIL");
		this.tDOTDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.DOTDOT");
		this.tNOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NOT");
		this.tSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.STAR");
		this.tSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.SLASH");
		this.tDIV = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.DIV");
		this.tMOD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.MOD");
		this.tPLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.PLUS");
		this.tMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.MINUS");
		this.tAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.AND");
		this.tOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.OR");
		this.tASSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.ASSIGN");
		this.tNUM_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.NUM_INT");
		this.tEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.EQUAL");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.ID");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.compiler.pascal.Pascal.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.compiler.pascal.Pascal".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//pascal:
	//	program=program;
	public PascalElements getPascalAccess() {
		return pPascal;
	}
	
	public ParserRule getPascalRule() {
		return getPascalAccess().getRule();
	}
	
	//program:
	//	heading=program_heading_block block=block ".";
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//program_heading_block:
	//	"program" name=ID ";";
	public Program_heading_blockElements getProgram_heading_blockAccess() {
		return pProgram_heading_block;
	}
	
	public ParserRule getProgram_heading_blockRule() {
		return getProgram_heading_blockAccess().getRule();
	}
	
	//identifier_list:
	//	names+=identifier ("," names+=identifier)*;
	public Identifier_listElements getIdentifier_listAccess() {
		return pIdentifier_list;
	}
	
	public ParserRule getIdentifier_listRule() {
		return getIdentifier_listAccess().getRule();
	}
	
	//identifier:
	//	id=ID;
	public IdentifierElements getIdentifierAccess() {
		return pIdentifier;
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	//block:
	//	(constantpart+=constant_definition_part | type_part+=type_definition_part | variablepart+=variable_declaration_part |
	//	procedure_function_part+=procedure_and_function_declaration_part)* statement=compound_statement;
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//constant_definition_part:
	//	'const' (constants+=constant_definition ';')+;
	public Constant_definition_partElements getConstant_definition_partAccess() {
		return pConstant_definition_part;
	}
	
	public ParserRule getConstant_definition_partRule() {
		return getConstant_definition_partAccess().getRule();
	}
	
	//constant_definition:
	//	name=ID EQUAL constant;
	public Constant_definitionElements getConstant_definitionAccess() {
		return pConstant_definition;
	}
	
	public ParserRule getConstant_definitionRule() {
		return getConstant_definitionAccess().getRule();
	}
	
	//constant:
	//	uns_number=unsigned_number
	//	| sign sig_number=unsigned_number
	//	| name_id=ID
	//	| sign sig_name_id=ID
	//	| string=STRING
	//	| booltype=bool;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//type_definition_part:
	//	"type" (types+=type_definition ";")+;
	public Type_definition_partElements getType_definition_partAccess() {
		return pType_definition_part;
	}
	
	public ParserRule getType_definition_partRule() {
		return getType_definition_partAccess().getRule();
	}
	
	//type_definition:
	//	name=ID EQUAL type=type;
	public Type_definitionElements getType_definitionAccess() {
		return pType_definition;
	}
	
	public ParserRule getType_definitionRule() {
		return getType_definitionAccess().getRule();
	}
	
	//variable_declaration_part:
	//	"var" variable+=variable_declaration (";" variable+=variable_declaration)* ";";
	public Variable_declaration_partElements getVariable_declaration_partAccess() {
		return pVariable_declaration_part;
	}
	
	public ParserRule getVariable_declaration_partRule() {
		return getVariable_declaration_partAccess().getRule();
	}
	
	//variable_declaration:
	//	list_names=identifier_list ":" type_variable=type;
	public Variable_declarationElements getVariable_declarationAccess() {
		return pVariable_declaration;
	}
	
	public ParserRule getVariable_declarationRule() {
		return getVariable_declarationAccess().getRule();
	}
	
	//compound_statement:
	//	"begin" sequence=statements "end";
	public Compound_statementElements getCompound_statementAccess() {
		return pCompound_statement;
	}
	
	public ParserRule getCompound_statementRule() {
		return getCompound_statementAccess().getRule();
	}
	
	//statements:
	//	statements+=statement (";" statements+=statement)*;
	public StatementsElements getStatementsAccess() {
		return pStatements;
	}
	
	public ParserRule getStatementsRule() {
		return getStatementsAccess().getRule();
	}
	
	//statement:
	//	{statement} statement+=unlabelled_statement?;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//unlabelled_statement:
	//	simple=simple_statement | structured=structured_statement;
	public Unlabelled_statementElements getUnlabelled_statementAccess() {
		return pUnlabelled_statement;
	}
	
	public ParserRule getUnlabelled_statementRule() {
		return getUnlabelled_statementAccess().getRule();
	}
	
	//simple_statement:
	//	assignment=assignment_statement | procedure=procedure_statement;
	public Simple_statementElements getSimple_statementAccess() {
		return pSimple_statement;
	}
	
	public ParserRule getSimple_statementRule() {
		return getSimple_statementAccess().getRule();
	}
	
	//assignment_statement:
	//	declared_variable=variable ASSIGN expression=expression;
	public Assignment_statementElements getAssignment_statementAccess() {
		return pAssignment_statement;
	}
	
	public ParserRule getAssignment_statementRule() {
		return getAssignment_statementAccess().getRule();
	}
	
	//variable:
	//	('@' variable_id=ID | variable_id=ID) ('[' indice+=expression ("," indice+=expression)* ']' | "(."
	//	expression+=expression ("," expression+=expression)* ".)" | "." names_exp+=ID | "^")*;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//expression:
	//	simple=simple_expression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//simple_expression:
	//	term_exp=term (operator=additive_operator expression=simple_expression)?;
	public Simple_expressionElements getSimple_expressionAccess() {
		return pSimple_expression;
	}
	
	public ParserRule getSimple_expressionRule() {
		return getSimple_expressionAccess().getRule();
	}
	
	//term:
	//	factor=signed_factor (operator=multiplicative_operator term2=term)?;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//signed_factor:
	//	(signal=PLUS | signal=MINUS)? factor=factor;
	public Signed_factorElements getSigned_factorAccess() {
		return pSigned_factor;
	}
	
	public ParserRule getSigned_factorRule() {
		return getSigned_factorAccess().getRule();
	}
	
	//factor:
	//	variable=variable
	//	| "(" expression=expression ")"
	//	| function=function_designator
	//	| constant=unsigned_constant
	//	| NOT not_factor=factor
	//	| bool_factor=bool;
	public FactorElements getFactorAccess() {
		return pFactor;
	}
	
	public ParserRule getFactorRule() {
		return getFactorAccess().getRule();
	}
	
	//type:
	//	simple=simple_type
	//	| structured=structured_type;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//simple_type:
	//	type=type_identifier
	//	| subrange_type+=subrange_type;
	public Simple_typeElements getSimple_typeAccess() {
		return pSimple_type;
	}
	
	public ParserRule getSimple_typeRule() {
		return getSimple_typeAccess().getRule();
	}
	
	//subrange_type:
	//	constantInit=constant DOTDOT constantFinal=constant;
	public Subrange_typeElements getSubrange_typeAccess() {
		return pSubrange_type;
	}
	
	public ParserRule getSubrange_typeRule() {
		return getSubrange_typeAccess().getRule();
	}
	
	//structured_type:
	//	unpacked=unpacked_structured_type;
	public Structured_typeElements getStructured_typeAccess() {
		return pStructured_type;
	}
	
	public ParserRule getStructured_typeRule() {
		return getStructured_typeAccess().getRule();
	}
	
	//unpacked_structured_type:
	//	static_array=array_type
	//	| dynamic=dynamic_array_type;
	public Unpacked_structured_typeElements getUnpacked_structured_typeAccess() {
		return pUnpacked_structured_type;
	}
	
	public ParserRule getUnpacked_structured_typeRule() {
		return getUnpacked_structured_typeAccess().getRule();
	}
	
	//dynamic_array_type:
	//	"array" "of" type=type_identifier;
	public Dynamic_array_typeElements getDynamic_array_typeAccess() {
		return pDynamic_array_type;
	}
	
	public ParserRule getDynamic_array_typeRule() {
		return getDynamic_array_typeAccess().getRule();
	}
	
	//array_type:
	//	"array" "[" type_l=type_list "]" "of" type=type_identifier;
	public Array_typeElements getArray_typeAccess() {
		return pArray_type;
	}
	
	public ParserRule getArray_typeRule() {
		return getArray_typeAccess().getRule();
	}
	
	//type_list:
	//	indexes+=index_type ("," indexes+=index_type)*;
	public Type_listElements getType_listAccess() {
		return pType_list;
	}
	
	public ParserRule getType_listRule() {
		return getType_listAccess().getRule();
	}
	
	//index_type:
	//	content=simple_type;
	public Index_typeElements getIndex_typeAccess() {
		return pIndex_type;
	}
	
	public ParserRule getIndex_typeRule() {
		return getIndex_typeAccess().getRule();
	}
	
	//component_type:
	//	type;
	public Component_typeElements getComponent_typeAccess() {
		return pComponent_type;
	}
	
	public ParserRule getComponent_typeRule() {
		return getComponent_typeAccess().getRule();
	}
	
	//type_identifier:
	//	id=ID
	//	| (boolean='boolean' | integer='integer' | string='string');
	public Type_identifierElements getType_identifierAccess() {
		return pType_identifier;
	}
	
	public ParserRule getType_identifierRule() {
		return getType_identifierAccess().getRule();
	}
	
	//unsigned_constant:
	//	number=unsigned_number
	//	| string=STRING
	//	| nil=NIL;
	public Unsigned_constantElements getUnsigned_constantAccess() {
		return pUnsigned_constant;
	}
	
	public ParserRule getUnsigned_constantRule() {
		return getUnsigned_constantAccess().getRule();
	}
	
	//unsigned_number:
	//	numbers=unsigned_integer;
	public Unsigned_numberElements getUnsigned_numberAccess() {
		return pUnsigned_number;
	}
	
	public ParserRule getUnsigned_numberRule() {
		return getUnsigned_numberAccess().getRule();
	}
	
	//procedure_statement:
	//	name_id=ID ('(' parameters=parameter_list ')')?;
	public Procedure_statementElements getProcedure_statementAccess() {
		return pProcedure_statement;
	}
	
	public ParserRule getProcedure_statementRule() {
		return getProcedure_statementAccess().getRule();
	}
	
	//parameter_list:
	//	parameters+=actual_parameter (',' parameters+=actual_parameter)*;
	public Parameter_listElements getParameter_listAccess() {
		return pParameter_list;
	}
	
	public ParserRule getParameter_listRule() {
		return getParameter_listAccess().getRule();
	}
	
	//actual_parameter:
	//	content=expression;
	public Actual_parameterElements getActual_parameterAccess() {
		return pActual_parameter;
	}
	
	public ParserRule getActual_parameterRule() {
		return getActual_parameterAccess().getRule();
	}
	
	//structured_statement:
	//	compound_stat=compound_statement
	//	| conditional_stat=conditional_statement;
	public Structured_statementElements getStructured_statementAccess() {
		return pStructured_statement;
	}
	
	public ParserRule getStructured_statementRule() {
		return getStructured_statementAccess().getRule();
	}
	
	//conditional_statement:
	//	cond_statements=case_statement;
	public Conditional_statementElements getConditional_statementAccess() {
		return pConditional_statement;
	}
	
	public ParserRule getConditional_statementRule() {
		return getConditional_statementAccess().getRule();
	}
	
	//case_statement:
	//	"case" exp=expression "of" case_list+=case_list_element (";" case_list+=case_list_element)* ";"? ("else"
	//	case_statements=statements)? "end";
	public Case_statementElements getCase_statementAccess() {
		return pCase_statement;
	}
	
	public ParserRule getCase_statementRule() {
		return getCase_statementAccess().getRule();
	}
	
	//case_list_element:
	//	consts=const_list ":" case_statement=statement;
	public Case_list_elementElements getCase_list_elementAccess() {
		return pCase_list_element;
	}
	
	public ParserRule getCase_list_elementRule() {
		return getCase_list_elementAccess().getRule();
	}
	
	//const_list:
	//	constants+=constant ("," constants+=constant)*;
	public Const_listElements getConst_listAccess() {
		return pConst_list;
	}
	
	public ParserRule getConst_listRule() {
		return getConst_listAccess().getRule();
	}
	
	//unsigned_integer:
	//	NUM_INT;
	public Unsigned_integerElements getUnsigned_integerAccess() {
		return pUnsigned_integer;
	}
	
	public ParserRule getUnsigned_integerRule() {
		return getUnsigned_integerAccess().getRule();
	}
	
	//additive_operator:
	//	PLUS
	//	| MINUS
	//	| OR;
	public Additive_operatorElements getAdditive_operatorAccess() {
		return pAdditive_operator;
	}
	
	public ParserRule getAdditive_operatorRule() {
		return getAdditive_operatorAccess().getRule();
	}
	
	//multiplicative_operator:
	//	STAR
	//	| SLASH
	//	| DIV
	//	| MOD
	//	| AND;
	public Multiplicative_operatorElements getMultiplicative_operatorAccess() {
		return pMultiplicative_operator;
	}
	
	public ParserRule getMultiplicative_operatorRule() {
		return getMultiplicative_operatorAccess().getRule();
	}
	
	//procedure_and_function_declaration_part:
	//	subroutine=procedure_or_function_declaration ";";
	public Procedure_and_function_declaration_partElements getProcedure_and_function_declaration_partAccess() {
		return pProcedure_and_function_declaration_part;
	}
	
	public ParserRule getProcedure_and_function_declaration_partRule() {
		return getProcedure_and_function_declaration_partAccess().getRule();
	}
	
	//procedure_or_function_declaration:
	//	proc=procedure_declaration | func=function_declaration;
	public Procedure_or_function_declarationElements getProcedure_or_function_declarationAccess() {
		return pProcedure_or_function_declaration;
	}
	
	public ParserRule getProcedure_or_function_declarationRule() {
		return getProcedure_or_function_declarationAccess().getRule();
	}
	
	//procedure_declaration:
	//	procedure names=ID parameters=formal_parameter_list? ';' block=block;
	public Procedure_declarationElements getProcedure_declarationAccess() {
		return pProcedure_declaration;
	}
	
	public ParserRule getProcedure_declarationRule() {
		return getProcedure_declarationAccess().getRule();
	}
	
	//procedure_type:
	//	{procedure_type} procedure types=formal_parameter_list?;
	public Procedure_typeElements getProcedure_typeAccess() {
		return pProcedure_type;
	}
	
	public ParserRule getProcedure_typeRule() {
		return getProcedure_typeAccess().getRule();
	}
	
	//function_declaration:
	//	function names=ID parameters=formal_parameter_list? ':'
	//	types=result_type ';' block=block;
	public Function_declarationElements getFunction_declarationAccess() {
		return pFunction_declaration;
	}
	
	public ParserRule getFunction_declarationRule() {
		return getFunction_declarationAccess().getRule();
	}
	
	//function_type:
	//	function parameters=formal_parameter_list? ':' types=result_type;
	public Function_typeElements getFunction_typeAccess() {
		return pFunction_type;
	}
	
	public ParserRule getFunction_typeRule() {
		return getFunction_typeAccess().getRule();
	}
	
	//function_designator:
	//	name_function=ID '(' parameters=parameter_list ')';
	public Function_designatorElements getFunction_designatorAccess() {
		return pFunction_designator;
	}
	
	public ParserRule getFunction_designatorRule() {
		return getFunction_designatorAccess().getRule();
	}
	
	//formal_parameter_list:
	//	'(' parameters+=formal_parameter_section (';' parameters+=formal_parameter_section)* ')';
	public Formal_parameter_listElements getFormal_parameter_listAccess() {
		return pFormal_parameter_list;
	}
	
	public ParserRule getFormal_parameter_listRule() {
		return getFormal_parameter_listAccess().getRule();
	}
	
	//formal_parameter_section:
	//	parameters+=parameter_group
	//	| 'var' parameters+=parameter_group
	//	| function parameters+=parameter_group
	//	| procedure parameters+=parameter_group;
	public Formal_parameter_sectionElements getFormal_parameter_sectionAccess() {
		return pFormal_parameter_section;
	}
	
	public ParserRule getFormal_parameter_sectionRule() {
		return getFormal_parameter_sectionAccess().getRule();
	}
	
	//parameter_group:
	//	names=identifier_list ":" types=type_identifier;
	public Parameter_groupElements getParameter_groupAccess() {
		return pParameter_group;
	}
	
	public ParserRule getParameter_groupRule() {
		return getParameter_groupAccess().getRule();
	}
	
	//result_type:
	//	type_identifier;
	public Result_typeElements getResult_typeAccess() {
		return pResult_type;
	}
	
	public ParserRule getResult_typeRule() {
		return getResult_typeAccess().getRule();
	}
	
	//bool:
	//	"true" | "false";
	public BoolElements getBoolAccess() {
		return pBool;
	}
	
	public ParserRule getBoolRule() {
		return getBoolAccess().getRule();
	}
	
	//procedure:
	//	'procedure';
	public ProcedureElements getProcedureAccess() {
		return pProcedure;
	}
	
	public ParserRule getProcedureRule() {
		return getProcedureAccess().getRule();
	}
	
	//function:
	//	'function';
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}
	
	//sign:
	//	PLUS
	//	| MINUS;
	public SignElements getSignAccess() {
		return pSign;
	}
	
	public ParserRule getSignRule() {
		return getSignAccess().getRule();
	}
	
	//terminal NIL:
	//	'nil';
	public TerminalRule getNILRule() {
		return tNIL;
	}
	
	//terminal DOTDOT:
	//	'..';
	public TerminalRule getDOTDOTRule() {
		return tDOTDOT;
	}
	
	//terminal NOT:
	//	('N' | 'n') ('O' | 'o') ('T' | 't');
	public TerminalRule getNOTRule() {
		return tNOT;
	}
	
	//terminal STAR:
	//	'*';
	public TerminalRule getSTARRule() {
		return tSTAR;
	}
	
	//terminal SLASH:
	//	'/';
	public TerminalRule getSLASHRule() {
		return tSLASH;
	}
	
	//terminal DIV:
	//	('D' | 'd') ('I' | 'i') ('V' | 'v');
	public TerminalRule getDIVRule() {
		return tDIV;
	}
	
	//terminal MOD:
	//	('M' | 'm') ('O' | 'o') ('D' | 'd');
	public TerminalRule getMODRule() {
		return tMOD;
	}
	
	//terminal PLUS:
	//	'+';
	public TerminalRule getPLUSRule() {
		return tPLUS;
	}
	
	//terminal MINUS:
	//	'-';
	public TerminalRule getMINUSRule() {
		return tMINUS;
	}
	
	//terminal AND:
	//	('A' | 'a') ('N' | 'n') ('D' | 'd');
	public TerminalRule getANDRule() {
		return tAND;
	}
	
	//terminal OR:
	//	('O' | 'o') ('R' | 'r');
	public TerminalRule getORRule() {
		return tOR;
	}
	
	//terminal ASSIGN:
	//	':=';
	public TerminalRule getASSIGNRule() {
		return tASSIGN;
	}
	
	//terminal NUM_INT:
	//	'0'..'9'+;
	public TerminalRule getNUM_INTRule() {
		return tNUM_INT;
	}
	
	//terminal EQUAL:
	//	'=';
	public TerminalRule getEQUALRule() {
		return tEQUAL;
	}
	
	//terminal ID:
	//	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal STRING:
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ML_COMMENT:
	//	'(*'->'*)' | '{'->'}';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}
